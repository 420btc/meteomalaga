{"ast":null,"code":"import AsyncStorage from'@react-native-async-storage/async-storage';import{addPendingReward}from\"./plantService\";const BETS_STORAGE_KEY='bets';const RESOLVED_BETS_STORAGE_KEY='recently_resolved_bets';const VERIFICATION_INTERVAL=60000;export const getLocalBets=async()=>{try{const betsString=await AsyncStorage.getItem(BETS_STORAGE_KEY);if(!betsString)return[];return JSON.parse(betsString);}catch(error){console.error('Error getting local bets:',error);return[];}};export const saveBet=async bet=>{try{const bets=await getLocalBets();const newBet=Object.assign({},bet,{id:Date.now(),timestamp:new Date().toISOString(),status:'pending'});const updatedBets=[newBet,...bets];await AsyncStorage.setItem(BETS_STORAGE_KEY,JSON.stringify(updatedBets));return newBet;}catch(error){console.error('Error saving bet:',error);throw new Error('Error saving bet');}};export const resolveBet=async(betId,actualValue)=>{try{const betsString=await AsyncStorage.getItem(BETS_STORAGE_KEY);if(!betsString)return;const bets=JSON.parse(betsString);const betIndex=bets.findIndex(bet=>bet.id===betId);if(betIndex===-1)return;const bet=bets[betIndex];let success=false;let betType='rain';if(bet.type==='rain'){success=Math.abs(bet.value-actualValue)<=2;betType='rain';}else if(bet.type==='temperature_min'){success=Math.abs(bet.value-actualValue)<=1;betType='temp_min';}else if(bet.type==='temperature_max'){success=Math.abs(bet.value-actualValue)<=1;betType='temp_max';}bet.status=success?'won':'lost';bet.actualValue=actualValue;bet.resolvedAt=new Date().toISOString();bets[betIndex]=bet;await AsyncStorage.setItem(BETS_STORAGE_KEY,JSON.stringify(bets));if(success){await addPendingReward(betType,true);}return{success,bet};}catch(error){console.error('Error resolving bet:',error);return{success:false};}};export const startBackgroundVerification=callback=>{let intervalId;const verifyBets=async()=>{try{const bets=await getLocalBets();const pendingBets=bets.filter(bet=>bet.status==='pending');if(pendingBets.length===0)return;const now=new Date();const resolvedBets=[];let totalCoinsWon=0;for(const bet of pendingBets){const betDate=new Date(bet.date);if(betDate<=now){const actualValue=Math.random()*30;const{success,bet:resolvedBet}=(await resolveBet(bet.id,actualValue))||{};if(resolvedBet){resolvedBets.push(resolvedBet);if(success){const winnings=bet.coins*bet.leverage;totalCoinsWon+=winnings;}}}}if(resolvedBets.length>0){await storeRecentlyResolvedBets(resolvedBets);callback(resolvedBets,totalCoinsWon);}}catch(error){console.error('Error verifying bets:',error);}};intervalId=setInterval(verifyBets,VERIFICATION_INTERVAL);return()=>{clearInterval(intervalId);};};const storeRecentlyResolvedBets=async resolvedBets=>{try{const recentlyResolvedBetsString=await AsyncStorage.getItem(RESOLVED_BETS_STORAGE_KEY);let recentlyResolvedBets=[];if(recentlyResolvedBetsString){recentlyResolvedBets=JSON.parse(recentlyResolvedBetsString);}recentlyResolvedBets=[...recentlyResolvedBets,...resolvedBets];await AsyncStorage.setItem(RESOLVED_BETS_STORAGE_KEY,JSON.stringify(recentlyResolvedBets));}catch(error){console.error('Error storing recently resolved bets:',error);}};export const getAndClearRecentlyResolvedBets=async()=>{try{const recentlyResolvedBetsString=await AsyncStorage.getItem(RESOLVED_BETS_STORAGE_KEY);if(!recentlyResolvedBetsString){return[];}const recentlyResolvedBets=JSON.parse(recentlyResolvedBetsString);await AsyncStorage.setItem(RESOLVED_BETS_STORAGE_KEY,JSON.stringify([]));return recentlyResolvedBets;}catch(error){console.error('Error getting and clearing recently resolved bets:',error);return[];}};export const cleanupOldBets=async()=>{try{const bets=await getLocalBets();const now=new Date();const thirtyDaysAgo=new Date(now.getTime()-30*24*60*60*1000);const filteredBets=bets.filter(bet=>{const betDate=new Date(bet.timestamp);return betDate>=thirtyDaysAgo;});if(filteredBets.length!==bets.length){await AsyncStorage.setItem(BETS_STORAGE_KEY,JSON.stringify(filteredBets));}}catch(error){console.error('Error cleaning up old bets:',error);}};export const getTemperatureOdds=(temperature,isMin)=>{const baseOdds=1.5;const extremityFactor=isMin?Math.max(0,(20-temperature)/10):Math.max(0,(temperature-20)/10);return Math.min(3.0,Math.max(1.2,baseOdds+extremityFactor));};export const getRemainingTemperatureBets=async()=>{try{const bets=await getLocalBets();const today=new Date().toISOString().split('T')[0];const tempBetsToday=bets.filter(bet=>{const betDate=new Date(bet.timestamp).toISOString().split('T')[0];return betDate===today&&(bet.option==='temp_min'||bet.option==='temp_max');});return Math.max(0,2-tempBetsToday.length);}catch(error){console.error('Error getting remaining temperature bets:',error);return 0;}};export const showBetResolutionNotification=(resolvedBets,coinsWon)=>{console.log('Bets resolved:',resolvedBets.length);console.log('Coins won:',coinsWon);};","map":{"version":3,"names":["AsyncStorage","addPendingReward","BETS_STORAGE_KEY","RESOLVED_BETS_STORAGE_KEY","VERIFICATION_INTERVAL","getLocalBets","betsString","getItem","JSON","parse","error","console","saveBet","bet","bets","newBet","Object","assign","id","Date","now","timestamp","toISOString","status","updatedBets","setItem","stringify","Error","resolveBet","betId","actualValue","betIndex","findIndex","success","betType","type","Math","abs","value","resolvedAt","startBackgroundVerification","callback","intervalId","verifyBets","pendingBets","filter","length","resolvedBets","totalCoinsWon","betDate","date","random","resolvedBet","push","winnings","coins","leverage","storeRecentlyResolvedBets","setInterval","clearInterval","recentlyResolvedBetsString","recentlyResolvedBets","getAndClearRecentlyResolvedBets","cleanupOldBets","thirtyDaysAgo","getTime","filteredBets","getTemperatureOdds","temperature","isMin","baseOdds","extremityFactor","max","min","getRemainingTemperatureBets","today","split","tempBetsToday","option","showBetResolutionNotification","coinsWon","log"],"sources":["/Users/atemjohnatem/Downloads/meteo-malaga/src/services/localBetService.ts"],"sourcesContent":["import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { Bet } from '../types/weather';\nimport { addPendingReward } from './plantService';\n\n// Constants\nconst BETS_STORAGE_KEY = 'bets';\nconst RESOLVED_BETS_STORAGE_KEY = 'recently_resolved_bets';\nconst VERIFICATION_INTERVAL = 60000; // 1 minute\n\n// Get all local bets\nexport const getLocalBets = async (): Promise<Bet[]> => {\n  try {\n    const betsString = await AsyncStorage.getItem(BETS_STORAGE_KEY);\n    if (!betsString) return [];\n    \n    return JSON.parse(betsString);\n  } catch (error) {\n    console.error('Error getting local bets:', error);\n    return [];\n  }\n};\n\n// Save a bet locally\nexport const saveBet = async (bet: Bet): Promise<Bet> => {\n  try {\n    const bets = await getLocalBets();\n    \n    // Add the new bet\n    const newBet = {\n      ...bet,\n      id: Date.now(), // Use timestamp as ID\n      timestamp: new Date().toISOString(),\n      status: 'pending'\n    };\n    \n    const updatedBets = [newBet, ...bets];\n    await AsyncStorage.setItem(BETS_STORAGE_KEY, JSON.stringify(updatedBets));\n    \n    return newBet;\n  } catch (error) {\n    console.error('Error saving bet:', error);\n    throw new Error('Error saving bet');\n  }\n};\n\n// Resolve a bet with the actual value\nexport const resolveBet = async (betId: number, actualValue: number) => {\n  try {\n    const betsString = await AsyncStorage.getItem(BETS_STORAGE_KEY);\n    if (!betsString) return;\n    \n    const bets = JSON.parse(betsString);\n    const betIndex = bets.findIndex((bet: any) => bet.id === betId);\n    \n    if (betIndex === -1) return;\n    \n    const bet = bets[betIndex];\n    \n    // Determine if the bet was successful based on the bet type\n    let success = false;\n    let betType: 'rain' | 'temp_min' | 'temp_max' = 'rain';\n    \n    if (bet.type === 'rain') {\n      // Rain bet: success if within ±2mm\n      success = Math.abs(bet.value - actualValue) <= 2;\n      betType = 'rain';\n    } else if (bet.type === 'temperature_min') {\n      // Min temperature bet: success if within ±1°C\n      success = Math.abs(bet.value - actualValue) <= 1;\n      betType = 'temp_min';\n    } else if (bet.type === 'temperature_max') {\n      // Max temperature bet: success if within ±1°C\n      success = Math.abs(bet.value - actualValue) <= 1;\n      betType = 'temp_max';\n    }\n    \n    // Update bet status\n    bet.status = success ? 'won' : 'lost';\n    bet.actualValue = actualValue;\n    bet.resolvedAt = new Date().toISOString();\n    \n    bets[betIndex] = bet;\n    await AsyncStorage.setItem(BETS_STORAGE_KEY, JSON.stringify(bets));\n    \n    // Add reward to plant if bet was successful\n    if (success) {\n      await addPendingReward(betType, true);\n    }\n    \n    return { success, bet };\n  } catch (error) {\n    console.error('Error resolving bet:', error);\n    return { success: false };\n  }\n};\n\n// Start background verification of bets\nexport const startBackgroundVerification = (\n  callback: (resolvedBets: Bet[], coinsWon: number) => void\n) => {\n  let intervalId: NodeJS.Timeout;\n  \n  const verifyBets = async () => {\n    try {\n      const bets = await getLocalBets();\n      const pendingBets = bets.filter(bet => bet.status === 'pending');\n      \n      if (pendingBets.length === 0) return;\n      \n      const now = new Date();\n      const resolvedBets: Bet[] = [];\n      let totalCoinsWon = 0;\n      \n      for (const bet of pendingBets) {\n        const betDate = new Date(bet.date);\n        \n        // Check if bet date has passed\n        if (betDate <= now) {\n          // TODO: In a real app, we would fetch actual weather data here\n          // For now, we'll use a random value for demonstration\n          const actualValue = Math.random() * 30; // Random value between 0 and 30\n          \n          const { success, bet: resolvedBet } = await resolveBet(bet.id, actualValue) || {};\n          \n          if (resolvedBet) {\n            resolvedBets.push(resolvedBet);\n            \n            if (success) {\n              const winnings = bet.coins * bet.leverage;\n              totalCoinsWon += winnings;\n            }\n          }\n        }\n      }\n      \n      if (resolvedBets.length > 0) {\n        // Store recently resolved bets\n        await storeRecentlyResolvedBets(resolvedBets);\n        \n        // Call the callback with resolved bets and coins won\n        callback(resolvedBets, totalCoinsWon);\n      }\n    } catch (error) {\n      console.error('Error verifying bets:', error);\n    }\n  };\n  \n  // Start the interval\n  intervalId = setInterval(verifyBets, VERIFICATION_INTERVAL);\n  \n  // Return a function to stop the interval\n  return () => {\n    clearInterval(intervalId);\n  };\n};\n\n// Store recently resolved bets\nconst storeRecentlyResolvedBets = async (resolvedBets: Bet[]) => {\n  try {\n    const recentlyResolvedBetsString = await AsyncStorage.getItem(RESOLVED_BETS_STORAGE_KEY);\n    let recentlyResolvedBets: Bet[] = [];\n    \n    if (recentlyResolvedBetsString) {\n      recentlyResolvedBets = JSON.parse(recentlyResolvedBetsString);\n    }\n    \n    // Add new resolved bets\n    recentlyResolvedBets = [...recentlyResolvedBets, ...resolvedBets];\n    \n    // Store the updated list\n    await AsyncStorage.setItem(RESOLVED_BETS_STORAGE_KEY, JSON.stringify(recentlyResolvedBets));\n  } catch (error) {\n    console.error('Error storing recently resolved bets:', error);\n  }\n};\n\n// Get and clear recently resolved bets\nexport const getAndClearRecentlyResolvedBets = async (): Promise<Bet[]> => {\n  try {\n    const recentlyResolvedBetsString = await AsyncStorage.getItem(RESOLVED_BETS_STORAGE_KEY);\n    \n    if (!recentlyResolvedBetsString) {\n      return [];\n    }\n    \n    const recentlyResolvedBets: Bet[] = JSON.parse(recentlyResolvedBetsString);\n    \n    // Clear the list\n    await AsyncStorage.setItem(RESOLVED_BETS_STORAGE_KEY, JSON.stringify([]));\n    \n    return recentlyResolvedBets;\n  } catch (error) {\n    console.error('Error getting and clearing recently resolved bets:', error);\n    return [];\n  }\n};\n\n// Clean up old bets (older than 30 days)\nexport const cleanupOldBets = async (): Promise<void> => {\n  try {\n    const bets = await getLocalBets();\n    const now = new Date();\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    \n    const filteredBets = bets.filter(bet => {\n      const betDate = new Date(bet.timestamp);\n      return betDate >= thirtyDaysAgo;\n    });\n    \n    if (filteredBets.length !== bets.length) {\n      await AsyncStorage.setItem(BETS_STORAGE_KEY, JSON.stringify(filteredBets));\n    }\n  } catch (error) {\n    console.error('Error cleaning up old bets:', error);\n  }\n};\n\n// Calculate odds for temperature bets\nexport const getTemperatureOdds = (temperature: number, isMin: boolean): number => {\n  // Base odds calculation\n  const baseOdds = 1.5;\n  \n  // Adjust odds based on temperature extremity\n  // For minimum temperature, lower values have higher odds\n  // For maximum temperature, higher values have higher odds\n  const extremityFactor = isMin \n    ? Math.max(0, (20 - temperature) / 10) // Lower min temps get higher odds\n    : Math.max(0, (temperature - 20) / 10); // Higher max temps get higher odds\n  \n  // Calculate final odds (between 1.2 and 3.0)\n  return Math.min(3.0, Math.max(1.2, baseOdds + extremityFactor));\n};\n\n// Get remaining temperature bets for today\nexport const getRemainingTemperatureBets = async (): Promise<number> => {\n  try {\n    const bets = await getLocalBets();\n    const today = new Date().toISOString().split('T')[0];\n    \n    // Count temperature bets made today\n    const tempBetsToday = bets.filter(bet => {\n      const betDate = new Date(bet.timestamp).toISOString().split('T')[0];\n      return betDate === today && (bet.option === 'temp_min' || bet.option === 'temp_max');\n    });\n    \n    // Maximum 2 temperature bets per day\n    return Math.max(0, 2 - tempBetsToday.length);\n  } catch (error) {\n    console.error('Error getting remaining temperature bets:', error);\n    return 0;\n  }\n};\n\n// Show notification about resolved bets\nexport const showBetResolutionNotification = (resolvedBets: Bet[], coinsWon: number): void => {\n  // In a real app, this would show a notification\n  // For now, we'll just log to console\n  console.log('Bets resolved:', resolvedBets.length);\n  console.log('Coins won:', coinsWon);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}