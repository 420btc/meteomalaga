{"ast":null,"code":"import{fetchCurrentRainData,fetchCurrentTemperatureData,fetchCurrentWindData}from\"../services/weatherService\";import AsyncStorage from'@react-native-async-storage/async-storage';const PENDING_RESOLUTIONS_KEY='pendingBetResolutions';const FAILED_RESOLUTIONS_KEY='failedBetResolutions';const RESOLUTION_ATTEMPTS_KEY='betResolutionAttempts';const MAX_RETRY_ATTEMPTS=5;export const resolveBet=async bet=>{try{if(bet.verified||bet.status==='ganada'||bet.status==='perdida'){return bet;}const now=new Date();const verificationTime=new Date(bet.verificationTime||'');if(isNaN(verificationTime.getTime())){console.error('Tiempo de verificación inválido para la apuesta:',bet.id);await logResolutionError(bet,'Tiempo de verificación inválido');return Object.assign({},bet,{resolution_explanation:'No se pudo resolver: tiempo de verificación inválido. Se reintentará más tarde.'});}if(now<verificationTime){return bet;}await recordResolutionAttempt(bet);const[currentRainAmount,currentTemperature,currentWind]=await Promise.all([fetchCurrentRainData().catch(error=>{console.error('Error al obtener datos de lluvia:',error);return null;}),fetchCurrentTemperatureData().catch(error=>{console.error('Error al obtener datos de temperatura:',error);return null;}),fetchCurrentWindData().catch(error=>{console.error('Error al obtener datos de viento:',error);return null;})]);if((bet.option==='rain_yes'||bet.option==='rain_no'||bet.option==='rain_amount')&&currentRainAmount===null||(bet.option==='temp_min'||bet.option==='temp_max'||bet.option==='temperature')&&currentTemperature===null||bet.option==='wind_max'&&currentWind===null){console.error('Datos meteorológicos no disponibles para resolver la apuesta:',bet.id);await addToPendingResolutions(bet);return Object.assign({},bet,{resolution_explanation:'Resolución pendiente: no se pudieron obtener datos meteorológicos. Se reintentará automáticamente.'});}let result=0;let won=false;let resolution_explanation='';if(bet.option==='rain_yes'||bet.option==='rain_no'||bet.option==='rain_amount'){result=currentRainAmount||0;if(bet.option==='rain_yes'){won=result>0;if(won){resolution_explanation=`¡Ganaste! Predijiste correctamente que llovería. La cantidad de lluvia registrada fue de ${result.toFixed(2)} mm.`;}else{resolution_explanation=`Perdiste. Predijiste que llovería, pero no se registró lluvia (0 mm). Las condiciones estaban secas durante el período de verificación.`;}}else if(bet.option==='rain_no'){won=result===0;if(won){resolution_explanation=`¡Ganaste! Predijiste correctamente que no llovería. No se registró lluvia (0 mm) durante el período de verificación.`;}else{resolution_explanation=`Perdiste. Predijiste que no llovería, pero se registraron ${result.toFixed(2)} mm de lluvia durante el período de verificación.`;}}else if(bet.option==='rain_amount'){const betValue=bet.rain_mm!==null?bet.rain_mm:bet.value;const margin=0.5;won=Math.abs((betValue||0)-result)<=margin;if(won){resolution_explanation=`¡Ganaste! Tu predicción de ${betValue} mm de lluvia estaba dentro del margen de ±${margin} mm del valor real (${result.toFixed(2)} mm).`;}else{const difference=Math.abs((betValue||0)-result).toFixed(2);resolution_explanation=`Perdiste. Tu predicción de ${betValue} mm de lluvia difería ${difference} mm del valor real (${result.toFixed(2)} mm), superando el margen permitido de ±${margin} mm.`;}}}else if(bet.option==='temp_min'){if(!currentTemperature){await addToPendingResolutions(bet);return Object.assign({},bet,{resolution_explanation:'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'});}result=currentTemperature.min;const betValue=bet.temp_min_c!==null?bet.temp_min_c:bet.value;const margin=1.0;won=Math.abs((betValue||0)-result)<=margin;if(won){resolution_explanation=`¡Ganaste! Tu predicción de temperatura mínima de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;}else{const difference=Math.abs((betValue||0)-result).toFixed(1);resolution_explanation=`Perdiste. Tu predicción de temperatura mínima de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;}}else if(bet.option==='temp_max'){if(!currentTemperature){await addToPendingResolutions(bet);return Object.assign({},bet,{resolution_explanation:'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'});}result=currentTemperature.max;const betValue=bet.temp_max_c!==null?bet.temp_max_c:bet.value;const margin=1.0;won=Math.abs((betValue||0)-result)<=margin;if(won){resolution_explanation=`¡Ganaste! Tu predicción de temperatura máxima de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;}else{const difference=Math.abs((betValue||0)-result).toFixed(1);resolution_explanation=`Perdiste. Tu predicción de temperatura máxima de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;}}else if(bet.option==='temperature'){if(!currentTemperature){await addToPendingResolutions(bet);return Object.assign({},bet,{resolution_explanation:'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'});}result=currentTemperature.current;const betValue=bet.temperature_c!==null?bet.temperature_c:bet.value;const margin=1.0;won=Math.abs((betValue||0)-result)<=margin;if(won){resolution_explanation=`¡Ganaste! Tu predicción de temperatura actual de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;}else{const difference=Math.abs((betValue||0)-result).toFixed(1);resolution_explanation=`Perdiste. Tu predicción de temperatura actual de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;}}else if(bet.option==='wind_max'){if(!currentWind){await addToPendingResolutions(bet);return Object.assign({},bet,{resolution_explanation:'Resolución pendiente: no se pudieron obtener datos de viento. Se reintentará automáticamente.'});}result=currentWind.max;const betValue=bet.wind_kmh_max!==null?bet.wind_kmh_max:bet.value;const margin=3.0;won=Math.abs((betValue||0)-result)<=margin;if(won){resolution_explanation=`¡Ganaste! Tu predicción de velocidad máxima del viento de ${betValue} km/h estaba dentro del margen de ±${margin} km/h del valor real (${result.toFixed(1)} km/h).`;}else{const difference=Math.abs((betValue||0)-result).toFixed(1);resolution_explanation=`Perdiste. Tu predicción de velocidad máxima del viento de ${betValue} km/h difería ${difference} km/h del valor real (${result.toFixed(1)} km/h), superando el margen permitido de ±${margin} km/h.`;}}const resolvedBet=Object.assign({},bet,{result,won,verified:true,status:won?'ganada':'perdida',resolution_explanation});await removeFromPendingResolutions(bet.id);return resolvedBet;}catch(error){console.error('Error al resolver la apuesta:',error,bet.id);await logResolutionError(bet,error.message||'Error desconocido');await addToPendingResolutions(bet);return Object.assign({},bet,{resolution_explanation:'Error al resolver la apuesta. Se reintentará automáticamente.'});}};export const resolveAllPendingBets=async()=>{try{const betsJson=await AsyncStorage.getItem('local_bets');if(!betsJson)return;const bets=JSON.parse(betsJson);const now=new Date();const pendingBets=bets.filter(bet=>bet.status==='pending'&&!bet.verified&&new Date(bet.verificationTime||'').getTime()<=now.getTime());if(pendingBets.length===0)return;const updatedBets=[...bets];let hasChanges=false;for(const bet of pendingBets){const resolvedBet=await resolveBet(bet);if(resolvedBet.verified!==bet.verified||resolvedBet.status!==bet.status||resolvedBet.result!==bet.result||resolvedBet.won!==bet.won){const index=updatedBets.findIndex(b=>b.id===bet.id);if(index!==-1){updatedBets[index]=resolvedBet;hasChanges=true;}}}if(hasChanges){await AsyncStorage.setItem('local_bets',JSON.stringify(updatedBets));}await retryPendingResolutions();}catch(error){console.error('Error al resolver apuestas pendientes:',error);}};const addToPendingResolutions=async bet=>{try{const pendingJson=await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);const pendingBets=pendingJson?JSON.parse(pendingJson):[];if(!pendingBets.includes(bet.id)){pendingBets.push(bet.id);await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY,JSON.stringify(pendingBets));}}catch(error){console.error('Error al agregar a resoluciones pendientes:',error);}};const removeFromPendingResolutions=async betId=>{try{const pendingJson=await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);if(!pendingJson)return;const pendingBets=JSON.parse(pendingJson);const updatedPending=pendingBets.filter(id=>id!==betId);await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY,JSON.stringify(updatedPending));}catch(error){console.error('Error al eliminar de resoluciones pendientes:',error);}};const logResolutionError=async(bet,errorMessage)=>{try{const failedJson=await AsyncStorage.getItem(FAILED_RESOLUTIONS_KEY);const failedResolutions=failedJson?JSON.parse(failedJson):{};failedResolutions[bet.id]={count:(failedResolutions[bet.id]?.count||0)+1,lastError:errorMessage,timestamp:new Date().toISOString()};await AsyncStorage.setItem(FAILED_RESOLUTIONS_KEY,JSON.stringify(failedResolutions));}catch(error){console.error('Error al registrar error de resolución:',error);}};const recordResolutionAttempt=async bet=>{try{const attemptsJson=await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);const attempts=attemptsJson?JSON.parse(attemptsJson):{};attempts[bet.id]=(attempts[bet.id]||0)+1;await AsyncStorage.setItem(RESOLUTION_ATTEMPTS_KEY,JSON.stringify(attempts));}catch(error){console.error('Error al registrar intento de resolución:',error);}};const retryPendingResolutions=async()=>{try{const pendingJson=await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);if(!pendingJson)return;const pendingBetIds=JSON.parse(pendingJson);if(pendingBetIds.length===0)return;const betsJson=await AsyncStorage.getItem('local_bets');if(!betsJson)return;const bets=JSON.parse(betsJson);const updatedBets=[...bets];let hasChanges=false;const attemptsJson=await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);const attempts=attemptsJson?JSON.parse(attemptsJson):{};for(const betId of pendingBetIds){if((attempts[betId]||0)>=MAX_RETRY_ATTEMPTS){console.warn(`Máximo de intentos alcanzado para la apuesta ${betId}. Marcando como fallida.`);const index=updatedBets.findIndex(b=>b.id===betId);if(index!==-1){updatedBets[index]=Object.assign({},updatedBets[index],{status:'error',verified:true,resolution_explanation:'No se pudo resolver la apuesta después de múltiples intentos. Por favor, contacta con soporte.'});hasChanges=true;}await removeFromPendingResolutions(betId);continue;}const bet=bets.find(b=>b.id===betId);if(!bet){await removeFromPendingResolutions(betId);continue;}const resolvedBet=await resolveBet(bet);if(resolvedBet.verified&&(resolvedBet.status==='ganada'||resolvedBet.status==='perdida')){const index=updatedBets.findIndex(b=>b.id===betId);if(index!==-1){updatedBets[index]=resolvedBet;hasChanges=true;}await removeFromPendingResolutions(betId);}}if(hasChanges){await AsyncStorage.setItem('local_bets',JSON.stringify(updatedBets));}}catch(error){console.error('Error al reintentar resoluciones pendientes:',error);}};export const cleanupResolutionData=async()=>{try{const attemptsJson=await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);if(attemptsJson){const attempts=JSON.parse(attemptsJson);const betsJson=await AsyncStorage.getItem('local_bets');const bets=betsJson?JSON.parse(betsJson):[];const currentBetIds=new Set(bets.map(bet=>bet.id));const updatedAttempts={};for(const[betId,count]of Object.entries(attempts)){if(currentBetIds.has(betId)){updatedAttempts[betId]=count;}}await AsyncStorage.setItem(RESOLUTION_ATTEMPTS_KEY,JSON.stringify(updatedAttempts));}const failedJson=await AsyncStorage.getItem(FAILED_RESOLUTIONS_KEY);if(failedJson){const failedResolutions=JSON.parse(failedJson);const betsJson=await AsyncStorage.getItem('local_bets');const bets=betsJson?JSON.parse(betsJson):[];const currentBetIds=new Set(bets.map(bet=>bet.id));const updatedFailedResolutions={};for(const[betId,data]of Object.entries(failedResolutions)){if(currentBetIds.has(betId)){updatedFailedResolutions[betId]=data;}}await AsyncStorage.setItem(FAILED_RESOLUTIONS_KEY,JSON.stringify(updatedFailedResolutions));}const pendingJson=await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);if(pendingJson){const pendingBetIds=JSON.parse(pendingJson);const betsJson=await AsyncStorage.getItem('local_bets');const bets=betsJson?JSON.parse(betsJson):[];const currentBetIds=new Set(bets.map(bet=>bet.id));const updatedPendingBetIds=pendingBetIds.filter(id=>currentBetIds.has(id));await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY,JSON.stringify(updatedPendingBetIds));}}catch(error){console.error('Error al limpiar datos de resolución:',error);}};export const resolveBets=async()=>{try{const pendingBets=await getPendingBets();const resolvedBets=[];let totalCoinsWon=0;for(const bet of pendingBets){const resolvedBet=await resolveBet(bet);if(resolvedBet.verified&&resolvedBet.status==='ganada'){const winnings=resolvedBet.coins*(resolvedBet.leverage||1);totalCoinsWon+=winnings;}if(resolvedBet.verified){resolvedBets.push(resolvedBet);}}return{resolvedBets,totalCoinsWon};}catch(error){console.error('Error al resolver apuestas:',error);return{resolvedBets:[],totalCoinsWon:0};}};const getPendingBets=async()=>{try{const betsString=await AsyncStorage.getItem('bets');if(!betsString)return[];const bets=JSON.parse(betsString);return bets.filter(bet=>!bet.verified&&bet.status==='pending');}catch(error){console.error('Error al obtener apuestas pendientes:',error);return[];}};","map":{"version":3,"names":["fetchCurrentRainData","fetchCurrentTemperatureData","fetchCurrentWindData","AsyncStorage","PENDING_RESOLUTIONS_KEY","FAILED_RESOLUTIONS_KEY","RESOLUTION_ATTEMPTS_KEY","MAX_RETRY_ATTEMPTS","resolveBet","bet","verified","status","now","Date","verificationTime","isNaN","getTime","console","error","id","logResolutionError","Object","assign","resolution_explanation","recordResolutionAttempt","currentRainAmount","currentTemperature","currentWind","Promise","all","catch","option","addToPendingResolutions","result","won","toFixed","betValue","rain_mm","value","margin","Math","abs","difference","min","temp_min_c","max","temp_max_c","current","temperature_c","wind_kmh_max","resolvedBet","removeFromPendingResolutions","message","resolveAllPendingBets","betsJson","getItem","bets","JSON","parse","pendingBets","filter","length","updatedBets","hasChanges","index","findIndex","b","setItem","stringify","retryPendingResolutions","pendingJson","includes","push","betId","updatedPending","errorMessage","failedJson","failedResolutions","count","lastError","timestamp","toISOString","attemptsJson","attempts","pendingBetIds","warn","find","cleanupResolutionData","currentBetIds","Set","map","updatedAttempts","entries","has","updatedFailedResolutions","data","updatedPendingBetIds","resolveBets","getPendingBets","resolvedBets","totalCoinsWon","winnings","coins","leverage","betsString"],"sources":["/Users/atemjohnatem/Downloads/meteo-malaga/src/utils/resolveBets.ts"],"sourcesContent":["import { Bet } from '../types/weather';\nimport { fetchCurrentRainData, fetchCurrentTemperatureData, fetchCurrentWindData } from '../services/weatherService';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// Claves para almacenamiento local\nconst PENDING_RESOLUTIONS_KEY = 'pendingBetResolutions';\nconst FAILED_RESOLUTIONS_KEY = 'failedBetResolutions';\nconst RESOLUTION_ATTEMPTS_KEY = 'betResolutionAttempts';\nconst MAX_RETRY_ATTEMPTS = 5;\n\n// Función para resolver una apuesta individual\nexport const resolveBet = async (bet: Bet): Promise<Bet> => {\n  try {\n    // Omitir si la apuesta ya está resuelta\n    if (bet.verified || bet.status === 'ganada' || bet.status === 'perdida') {\n      return bet;\n    }\n    \n    // Verificar si es momento de resolver la apuesta\n    const now = new Date();\n    const verificationTime = new Date(bet.verificationTime || '');\n    \n    if (isNaN(verificationTime.getTime())) {\n      console.error('Tiempo de verificación inválido para la apuesta:', bet.id);\n      await logResolutionError(bet, 'Tiempo de verificación inválido');\n      return {\n        ...bet,\n        resolution_explanation: 'No se pudo resolver: tiempo de verificación inválido. Se reintentará más tarde.'\n      };\n    }\n    \n    if (now < verificationTime) {\n      return bet; // Aún no es tiempo de resolver\n    }\n    \n    // Registrar intento de resolución\n    await recordResolutionAttempt(bet);\n    \n    // Obtener datos meteorológicos actuales\n    const [currentRainAmount, currentTemperature, currentWind] = await Promise.all([\n      fetchCurrentRainData().catch(error => {\n        console.error('Error al obtener datos de lluvia:', error);\n        return null;\n      }),\n      fetchCurrentTemperatureData().catch(error => {\n        console.error('Error al obtener datos de temperatura:', error);\n        return null;\n      }),\n      fetchCurrentWindData().catch(error => {\n        console.error('Error al obtener datos de viento:', error);\n        return null;\n      })\n    ]);\n    \n    // Verificar si se obtuvieron los datos necesarios\n    if (\n      (bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') && currentRainAmount === null ||\n      (bet.option === 'temp_min' || bet.option === 'temp_max' || bet.option === 'temperature') && currentTemperature === null ||\n      (bet.option === 'wind_max') && currentWind === null\n    ) {\n      console.error('Datos meteorológicos no disponibles para resolver la apuesta:', bet.id);\n      await addToPendingResolutions(bet);\n      return {\n        ...bet,\n        resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos meteorológicos. Se reintentará automáticamente.'\n      };\n    }\n    \n    // Determinar el resultado real según el tipo de apuesta\n    let result = 0;\n    let won = false;\n    let resolution_explanation = '';\n    \n    if (bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') {\n      result = currentRainAmount || 0;\n      \n      if (bet.option === 'rain_yes') {\n        won = result > 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que llovería. La cantidad de lluvia registrada fue de ${result.toFixed(2)} mm.`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que llovería, pero no se registró lluvia (0 mm). Las condiciones estaban secas durante el período de verificación.`;\n        }\n      } else if (bet.option === 'rain_no') {\n        won = result === 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que no llovería. No se registró lluvia (0 mm) durante el período de verificación.`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que no llovería, pero se registraron ${result.toFixed(2)} mm de lluvia durante el período de verificación.`;\n        }\n      } else if (bet.option === 'rain_amount') {\n        const betValue = bet.rain_mm !== null ? bet.rain_mm : bet.value;\n        \n        // Usar un margen fijo para todos los modos\n        const margin = 0.5;\n        won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±0.5mm\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de ${betValue} mm de lluvia estaba dentro del margen de ±${margin} mm del valor real (${result.toFixed(2)} mm).`;\n        } else {\n          const difference = Math.abs((betValue || 0) - result).toFixed(2);\n          resolution_explanation = `Perdiste. Tu predicción de ${betValue} mm de lluvia difería ${difference} mm del valor real (${result.toFixed(2)} mm), superando el margen permitido de ±${margin} mm.`;\n        }\n      }\n    } else if (bet.option === 'temp_min') {\n      if (!currentTemperature) {\n        await addToPendingResolutions(bet);\n                return {\n          ...bet,\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'\n        };\n      }\n      \n      result = currentTemperature.min;\n      const betValue = bet.temp_min_c !== null ? bet.temp_min_c : bet.value;\n      \n      // Usar un margen fijo para todos los modos\n      const margin = 1.0;\n      won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±1.0°C\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de temperatura mínima de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de temperatura mínima de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;\n      }\n    } else if (bet.option === 'temp_max') {\n      if (!currentTemperature) {\n        await addToPendingResolutions(bet);\n        return {\n          ...bet,\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'\n        };\n      }\n      \n      result = currentTemperature.max;\n      const betValue = bet.temp_max_c !== null ? bet.temp_max_c : bet.value;\n      \n      // Usar un margen fijo para todos los modos\n      const margin = 1.0;\n      won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±1.0°C\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de temperatura máxima de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de temperatura máxima de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;\n      }\n    } else if (bet.option === 'temperature') {\n      if (!currentTemperature) {\n        await addToPendingResolutions(bet);\n        return {\n          ...bet,\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'\n        };\n      }\n      \n      result = currentTemperature.current;\n      const betValue = bet.temperature_c !== null ? bet.temperature_c : bet.value;\n      \n      // Usar un margen fijo para todos los modos\n      const margin = 1.0;\n      won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±1.0°C\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de temperatura actual de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de temperatura actual de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;\n      }\n    } else if (bet.option === 'wind_max') {\n      if (!currentWind) {\n        await addToPendingResolutions(bet);\n        return {\n          ...bet,\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de viento. Se reintentará automáticamente.'\n        };\n      }\n      \n      result = currentWind.max;\n      const betValue = bet.wind_kmh_max !== null ? bet.wind_kmh_max : bet.value;\n      \n      // Usar un margen fijo para todos los modos\n      const margin = 3.0;\n      won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±3.0 km/h\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de velocidad máxima del viento de ${betValue} km/h estaba dentro del margen de ±${margin} km/h del valor real (${result.toFixed(1)} km/h).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de velocidad máxima del viento de ${betValue} km/h difería ${difference} km/h del valor real (${result.toFixed(1)} km/h), superando el margen permitido de ±${margin} km/h.`;\n      }\n    }\n    \n    // Actualizar la apuesta con el resultado\n    const resolvedBet: Bet = {\n      ...bet,\n      result,\n      won,\n      verified: true,\n      status: won ? 'ganada' : 'perdida',\n      resolution_explanation\n    };\n    \n    // Eliminar de las resoluciones pendientes si estaba allí\n    await removeFromPendingResolutions(bet.id);\n    \n    return resolvedBet;\n  } catch (error) {\n    console.error('Error al resolver la apuesta:', error, bet.id);\n    await logResolutionError(bet, error.message || 'Error desconocido');\n    await addToPendingResolutions(bet);\n    \n    return {\n      ...bet,\n      resolution_explanation: 'Error al resolver la apuesta. Se reintentará automáticamente.'\n    };\n  }\n};\n\n// Función para resolver todas las apuestas pendientes\nexport const resolveAllPendingBets = async (): Promise<void> => {\n  try {\n    // Obtener todas las apuestas del almacenamiento local\n    const betsJson = await AsyncStorage.getItem('local_bets');\n    if (!betsJson) return;\n    \n    const bets: Bet[] = JSON.parse(betsJson);\n    const now = new Date();\n    \n    // Filtrar apuestas pendientes que deberían resolverse\n    const pendingBets = bets.filter(bet => \n      bet.status === 'pending' && \n      !bet.verified && \n      new Date(bet.verificationTime || '').getTime() <= now.getTime()\n    );\n    \n    if (pendingBets.length === 0) return;\n    \n    // Resolver cada apuesta pendiente\n    const updatedBets = [...bets];\n    let hasChanges = false;\n    \n    for (const bet of pendingBets) {\n      const resolvedBet = await resolveBet(bet);\n      \n      // Si la apuesta cambió, actualizar en el array\n      if (\n        resolvedBet.verified !== bet.verified || \n        resolvedBet.status !== bet.status || \n        resolvedBet.result !== bet.result || \n        resolvedBet.won !== bet.won\n      ) {\n        const index = updatedBets.findIndex(b => b.id === bet.id);\n        if (index !== -1) {\n          updatedBets[index] = resolvedBet;\n          hasChanges = true;\n        }\n      }\n    }\n    \n    // Guardar las apuestas actualizadas si hubo cambios\n    if (hasChanges) {\n      await AsyncStorage.setItem('local_bets', JSON.stringify(updatedBets));\n    }\n    \n    // Intentar resolver apuestas pendientes anteriores\n    await retryPendingResolutions();\n  } catch (error) {\n    console.error('Error al resolver apuestas pendientes:', error);\n  }\n};\n\n// Función para agregar una apuesta a las resoluciones pendientes\nconst addToPendingResolutions = async (bet: Bet): Promise<void> => {\n  try {\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    const pendingBets: string[] = pendingJson ? JSON.parse(pendingJson) : [];\n    \n    // Agregar el ID de la apuesta si no está ya\n    if (!pendingBets.includes(bet.id)) {\n      pendingBets.push(bet.id);\n      await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY, JSON.stringify(pendingBets));\n    }\n  } catch (error) {\n    console.error('Error al agregar a resoluciones pendientes:', error);\n  }\n};\n\n// Función para eliminar una apuesta de las resoluciones pendientes\nconst removeFromPendingResolutions = async (betId: string): Promise<void> => {\n  try {\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    if (!pendingJson) return;\n    \n    const pendingBets: string[] = JSON.parse(pendingJson);\n    const updatedPending = pendingBets.filter(id => id !== betId);\n    \n    await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY, JSON.stringify(updatedPending));\n  } catch (error) {\n    console.error('Error al eliminar de resoluciones pendientes:', error);\n  }\n};\n\n// Función para registrar un error de resolución\nconst logResolutionError = async (bet: Bet, errorMessage: string): Promise<void> => {\n  try {\n    const failedJson = await AsyncStorage.getItem(FAILED_RESOLUTIONS_KEY);\n    const failedResolutions: Record<string, { count: number, lastError: string, timestamp: string }> = \n      failedJson ? JSON.parse(failedJson) : {};\n    \n    // Actualizar o agregar el registro de error\n    failedResolutions[bet.id] = {\n      count: (failedResolutions[bet.id]?.count || 0) + 1,\n      lastError: errorMessage,\n      timestamp: new Date().toISOString()\n    };\n    \n    await AsyncStorage.setItem(FAILED_RESOLUTIONS_KEY, JSON.stringify(failedResolutions));\n  } catch (error) {\n    console.error('Error al registrar error de resolución:', error);\n  }\n};\n\n// Función para registrar un intento de resolución\nconst recordResolutionAttempt = async (bet: Bet): Promise<void> => {\n  try {\n    const attemptsJson = await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);\n    const attempts: Record<string, number> = attemptsJson ? JSON.parse(attemptsJson) : {};\n    \n    // Incrementar el contador de intentos\n    attempts[bet.id] = (attempts[bet.id] || 0) + 1;\n    \n    await AsyncStorage.setItem(RESOLUTION_ATTEMPTS_KEY, JSON.stringify(attempts));\n  } catch (error) {\n    console.error('Error al registrar intento de resolución:', error);\n  }\n};\n\n// Función para reintentar resoluciones pendientes\nconst retryPendingResolutions = async (): Promise<void> => {\n  try {\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    if (!pendingJson) return;\n    \n    const pendingBetIds: string[] = JSON.parse(pendingJson);\n    if (pendingBetIds.length === 0) return;\n    \n    // Obtener todas las apuestas\n    const betsJson = await AsyncStorage.getItem('local_bets');\n    if (!betsJson) return;\n    \n    const bets: Bet[] = JSON.parse(betsJson);\n    const updatedBets = [...bets];\n    let hasChanges = false;\n    \n    // Obtener intentos de resolución\n    const attemptsJson = await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);\n    const attempts: Record<string, number> = attemptsJson ? JSON.parse(attemptsJson) : {};\n    \n    // Procesar cada apuesta pendiente\n    for (const betId of pendingBetIds) {\n      // Verificar si se ha excedido el número máximo de intentos\n      if ((attempts[betId] || 0) >= MAX_RETRY_ATTEMPTS) {\n        console.warn(`Máximo de intentos alcanzado para la apuesta ${betId}. Marcando como fallida.`);\n        \n        // Marcar la apuesta como fallida después de demasiados intentos\n        const index = updatedBets.findIndex(b => b.id === betId);\n        if (index !== -1) {\n          updatedBets[index] = {\n            ...updatedBets[index],\n            status: 'error',\n            verified: true,\n            resolution_explanation: 'No se pudo resolver la apuesta después de múltiples intentos. Por favor, contacta con soporte.'\n          };\n          hasChanges = true;\n        }\n        \n        // Eliminar de las resoluciones pendientes\n        await removeFromPendingResolutions(betId);\n        continue;\n      }\n      \n      // Encontrar la apuesta en el array\n      const bet = bets.find(b => b.id === betId);\n      if (!bet) {\n        await removeFromPendingResolutions(betId);\n        continue;\n      }\n      \n      // Intentar resolver la apuesta\n      const resolvedBet = await resolveBet(bet);\n      \n      // Si la apuesta se resolvió correctamente, actualizar en el array\n      if (resolvedBet.verified && (resolvedBet.status === 'ganada' || resolvedBet.status === 'perdida')) {\n        const index = updatedBets.findIndex(b => b.id === betId);\n        if (index !== -1) {\n          updatedBets[index] = resolvedBet;\n          hasChanges = true;\n        }\n        \n        // Eliminar de las resoluciones pendientes\n        await removeFromPendingResolutions(betId);\n      }\n    }\n    \n    // Guardar las apuestas actualizadas si hubo cambios\n    if (hasChanges) {\n      await AsyncStorage.setItem('local_bets', JSON.stringify(updatedBets));\n    }\n  } catch (error) {\n    console.error('Error al reintentar resoluciones pendientes:', error);\n  }\n};\n\n// Función para limpiar datos antiguos de resolución\nexport const cleanupResolutionData = async (): Promise<void> => {\n  try {\n    // Limpiar intentos de resolución antiguos\n    const attemptsJson = await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);\n    if (attemptsJson) {\n      const attempts: Record<string, number> = JSON.parse(attemptsJson);\n      \n      // Obtener apuestas actuales\n      const betsJson = await AsyncStorage.getItem('local_bets');\n      const bets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n      const currentBetIds = new Set(bets.map(bet => bet.id));\n      \n      // Filtrar intentos para mantener solo los de apuestas actuales\n      const updatedAttempts: Record<string, number> = {};\n      for (const [betId, count] of Object.entries(attempts)) {\n        if (currentBetIds.has(betId)) {\n          updatedAttempts[betId] = count;\n        }\n      }\n      \n      await AsyncStorage.setItem(RESOLUTION_ATTEMPTS_KEY, JSON.stringify(updatedAttempts));\n    }\n    \n    // Limpiar errores de resolución antiguos\n    const failedJson = await AsyncStorage.getItem(FAILED_RESOLUTIONS_KEY);\n    if (failedJson) {\n      const failedResolutions: Record<string, { count: number, lastError: string, timestamp: string }> = \n        JSON.parse(failedJson);\n      \n      // Obtener apuestas actuales\n      const betsJson = await AsyncStorage.getItem('local_bets');\n      const bets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n      const currentBetIds = new Set(bets.map(bet => bet.id));\n      \n      // Filtrar errores para mantener solo los de apuestas actuales\n      const updatedFailedResolutions: Record<string, { count: number, lastError: string, timestamp: string }> = {};\n      for (const [betId, data] of Object.entries(failedResolutions)) {\n        if (currentBetIds.has(betId)) {\n          updatedFailedResolutions[betId] = data;\n        }\n      }\n      \n      await AsyncStorage.setItem(FAILED_RESOLUTIONS_KEY, JSON.stringify(updatedFailedResolutions));\n    }\n    \n    // Verificar y limpiar resoluciones pendientes\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    if (pendingJson) {\n      const pendingBetIds: string[] = JSON.parse(pendingJson);\n      \n      // Obtener apuestas actuales\n      const betsJson = await AsyncStorage.getItem('local_bets');\n      const bets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n      const currentBetIds = new Set(bets.map(bet => bet.id));\n      \n      // Filtrar para mantener solo IDs de apuestas actuales\n      const updatedPendingBetIds = pendingBetIds.filter(id => currentBetIds.has(id));\n      \n      await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY, JSON.stringify(updatedPendingBetIds));\n    }\n  } catch (error) {\n    console.error('Error al limpiar datos de resolución:', error);\n  }\n};\n\n// Función para resolver todas las apuestas pendientes y devolver resultados\nexport const resolveBets = async (): Promise<{ resolvedBets: Bet[], totalCoinsWon: number }> => {\n  try {\n    const pendingBets = await getPendingBets();\n    const resolvedBets: Bet[] = [];\n    let totalCoinsWon = 0;\n    \n    for (const bet of pendingBets) {\n      const resolvedBet = await resolveBet(bet);\n      \n      if (resolvedBet.verified && resolvedBet.status === 'ganada') {\n        const winnings = resolvedBet.coins * (resolvedBet.leverage || 1);\n        totalCoinsWon += winnings;\n      }\n      \n      if (resolvedBet.verified) {\n        resolvedBets.push(resolvedBet);\n      }\n    }\n    \n    return { resolvedBets, totalCoinsWon };\n  } catch (error) {\n    console.error('Error al resolver apuestas:', error);\n    return { resolvedBets: [], totalCoinsWon: 0 };\n  }\n};\n\n// Función auxiliar para obtener apuestas pendientes\nconst getPendingBets = async (): Promise<Bet[]> => {\n  try {\n    const betsString = await AsyncStorage.getItem('bets');\n    if (!betsString) return [];\n    \n    const bets: Bet[] = JSON.parse(betsString);\n    return bets.filter(bet => !bet.verified && bet.status === 'pending');\n  } catch (error) {\n    console.error('Error al obtener apuestas pendientes:', error);\n    return [];\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}