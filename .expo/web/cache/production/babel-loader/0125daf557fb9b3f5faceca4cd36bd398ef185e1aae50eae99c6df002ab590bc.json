{"ast":null,"code":"import{toByteArray}from'base64-js';import{UnavailabilityError}from'expo-modules-core';import{CryptoDigestAlgorithm,CryptoEncoding}from\"./Crypto.types\";import ExpoCrypto from\"./ExpoCrypto\";export*from\"./Crypto.types\";class CryptoError extends TypeError{code='ERR_CRYPTO';constructor(message){super(`expo-crypto: ${message}`);}}export function getRandomBytes(byteCount){assertByteCount(byteCount,'getRandomBytes');const validByteCount=Math.floor(byteCount);if(false){if(!global.nativeCallSyncHook||global.__REMOTEDEV__){const array=new Uint8Array(validByteCount);for(let i=0;i<validByteCount;i++){array[i]=Math.floor(Math.random()*256);}return array;}}if(ExpoCrypto.getRandomValues){const byteArray=new Uint8Array(validByteCount);ExpoCrypto.getRandomValues(byteArray);return byteArray;}else if(ExpoCrypto.getRandomBase64String){const base64=ExpoCrypto.getRandomBase64String(validByteCount);return toByteArray(base64);}else{throw new UnavailabilityError('expo-crypto','getRandomBytes');}}export async function getRandomBytesAsync(byteCount){assertByteCount(byteCount,'getRandomBytesAsync');const validByteCount=Math.floor(byteCount);if(ExpoCrypto.getRandomValues){const byteArray=new Uint8Array(validByteCount);ExpoCrypto.getRandomValues(byteArray);return byteArray;}else if(ExpoCrypto.getRandomBase64StringAsync){const base64=await ExpoCrypto.getRandomBase64StringAsync(validByteCount);return toByteArray(base64);}else{throw new UnavailabilityError('expo-crypto','getRandomBytesAsync');}}function assertByteCount(value,methodName){if(typeof value!=='number'||isNaN(value)||Math.floor(value)<0||Math.floor(value)>1024){throw new TypeError(`expo-crypto: ${methodName}(${value}) expected a valid number from range 0...1024`);}}function assertAlgorithm(algorithm){if(!Object.values(CryptoDigestAlgorithm).includes(algorithm)){throw new CryptoError(`Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.')}`);}}function assertData(data){if(typeof data!=='string'){throw new CryptoError(`Invalid data provided. Expected a string.`);}}function assertEncoding(encoding){if(!Object.values(CryptoEncoding).includes(encoding)){throw new CryptoError(`Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(CryptoEncoding).join(', CryptoEncoding.')}`);}}export async function digestStringAsync(algorithm,data,options={encoding:CryptoEncoding.HEX}){if(!ExpoCrypto.digestStringAsync){throw new UnavailabilityError('expo-crypto','digestStringAsync');}assertAlgorithm(algorithm);assertData(data);assertEncoding(options.encoding);return await ExpoCrypto.digestStringAsync(algorithm,data,options);}export function getRandomValues(typedArray){ExpoCrypto.getRandomValues(typedArray);return typedArray;}export function randomUUID(){return ExpoCrypto.randomUUID();}const digestLengths={[CryptoDigestAlgorithm.SHA1]:20,[CryptoDigestAlgorithm.SHA256]:32,[CryptoDigestAlgorithm.SHA384]:48,[CryptoDigestAlgorithm.SHA512]:64,[CryptoDigestAlgorithm.MD2]:16,[CryptoDigestAlgorithm.MD4]:16,[CryptoDigestAlgorithm.MD5]:16};export function digest(algorithm,data){return new Promise((resolve,reject)=>{try{if(typeof ExpoCrypto.digestAsync==='function'){resolve(ExpoCrypto.digestAsync(algorithm,data));}else{const output=new Uint8Array(digestLengths[algorithm]);ExpoCrypto.digest(algorithm,output,data);resolve(output.buffer);}}catch(error){reject(error);}});}","map":{"version":3,"names":["toByteArray","UnavailabilityError","CryptoDigestAlgorithm","CryptoEncoding","ExpoCrypto","CryptoError","TypeError","code","constructor","message","getRandomBytes","byteCount","assertByteCount","validByteCount","Math","floor","global","nativeCallSyncHook","__REMOTEDEV__","array","Uint8Array","i","random","getRandomValues","byteArray","getRandomBase64String","base64","getRandomBytesAsync","getRandomBase64StringAsync","value","methodName","isNaN","assertAlgorithm","algorithm","Object","values","includes","keys","join","assertData","data","assertEncoding","encoding","digestStringAsync","options","HEX","typedArray","randomUUID","digestLengths","SHA1","SHA256","SHA384","SHA512","MD2","MD4","MD5","digest","Promise","resolve","reject","digestAsync","output","buffer","error"],"sources":["/Users/atemjohnatem/Downloads/meteo-malaga/node_modules/expo-crypto/src/Crypto.ts"],"sourcesContent":["import { toByteArray } from 'base64-js';\nimport { UnavailabilityError, UintBasedTypedArray, IntBasedTypedArray } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nimport ExpoCrypto from './ExpoCrypto';\n\ndeclare const global: any;\n\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * Falls back to `Math.random` during development to prevent issues with React Native Debugger.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return An array of random bytes with the same length as the `byteCount`.\n */\nexport function getRandomBytes(byteCount: number): Uint8Array {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      // remote javascript debugging is enabled\n      const array = new Uint8Array(validByteCount);\n      for (let i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    }\n  }\n  if (ExpoCrypto.getRandomValues) {\n    const byteArray = new Uint8Array(validByteCount);\n    ExpoCrypto.getRandomValues(byteArray);\n    return byteArray;\n  } else if (ExpoCrypto.getRandomBase64String) {\n    const base64 = ExpoCrypto.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-crypto', 'getRandomBytes');\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return A promise that fulfills with an array of random bytes with the same length as the `byteCount`.\n */\nexport async function getRandomBytesAsync(byteCount: number): Promise<Uint8Array> {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoCrypto.getRandomValues) {\n    const byteArray = new Uint8Array(validByteCount);\n    ExpoCrypto.getRandomValues(byteArray);\n    return byteArray;\n  } else if (ExpoCrypto.getRandomBase64StringAsync) {\n    const base64 = await ExpoCrypto.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-crypto', 'getRandomBytesAsync');\n  }\n}\n\nfunction assertByteCount(value: any, methodName: string): void {\n  if (\n    typeof value !== 'number' ||\n    isNaN(value) ||\n    Math.floor(value) < 0 ||\n    Math.floor(value) > 1024\n  ) {\n    throw new TypeError(\n      `expo-crypto: ${methodName}(${value}) expected a valid number from range 0...1024`\n    );\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * The `digestStringAsync()` method of `Crypto` generates a digest of the supplied `data` string with the provided digest `algorithm`.\n * A digest is a short fixed-length value derived from some variable-length input. **Cryptographic digests** should exhibit _collision-resistance_,\n * meaning that it's very difficult to generate multiple inputs that have equal digest values.\n * You can specify the returned string format as one of `CryptoEncoding`. By default, the resolved value will be formatted as a `HEX` string.\n * On web, this method can only be called from a secure origin (HTTPS) otherwise, an error will be thrown.\n *\n * @param algorithm The cryptographic hash function to use to transform a block of data into a fixed-size output.\n * @param data The value that will be used to generate a digest.\n * @param options Format of the digest string. Defaults to: `CryptoDigestOptions.HEX`.\n * @return Return a Promise which fulfills with a value representing the hashed input.\n *\n * @example\n * ```ts\n * const digest = await Crypto.digestStringAsync(\n *   Crypto.CryptoDigestAlgorithm.SHA512,\n *   'ðŸ¥“ Easy to Digest! ðŸ’™'\n * );\n * ```\n */\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n\n/**\n * The `getRandomValues()` method of `Crypto` fills a provided `TypedArray` with cryptographically secure random values.\n *\n * @param typedArray An integer based [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) to fill with cryptographically secure random values. It modifies the input array in place.\n * @return The input array filled with cryptographically secure random values.\n *\n * @example\n * ```ts\n * const byteArray = new Uint8Array(16);\n * Crypto.getRandomValues(byteArray);\n * console.log('Your lucky bytes: ' + byteArray);\n * ```\n */\nexport function getRandomValues<T extends IntBasedTypedArray | UintBasedTypedArray>(\n  typedArray: T\n): T {\n  ExpoCrypto.getRandomValues(typedArray);\n  return typedArray;\n}\n\n/**\n * The `randomUUID()` method returns a unique identifier based on the V4 UUID spec (RFC4122).\n * It uses cryptographically secure random values to generate the UUID.\n *\n * @return A string containing a newly generated UUIDv4 identifier\n * @example\n * ```ts\n * const UUID = Crypto.randomUUID();\n * console.log('Your UUID: ' + UUID);\n * ```\n */\nexport function randomUUID(): string {\n  return ExpoCrypto.randomUUID();\n}\n\nconst digestLengths = {\n  [CryptoDigestAlgorithm.SHA1]: 20,\n  [CryptoDigestAlgorithm.SHA256]: 32,\n  [CryptoDigestAlgorithm.SHA384]: 48,\n  [CryptoDigestAlgorithm.SHA512]: 64,\n  [CryptoDigestAlgorithm.MD2]: 16,\n  [CryptoDigestAlgorithm.MD4]: 16,\n  [CryptoDigestAlgorithm.MD5]: 16,\n};\n\n/**\n * The `digest()` method of `Crypto` generates a digest of the supplied `TypedArray` of bytes `data` with the provided digest `algorithm`.\n * A digest is a short fixed-length value derived from some variable-length input. **Cryptographic digests** should exhibit _collision-resistance_,\n * meaning that it's very difficult to generate multiple inputs that have equal digest values.\n * On web, this method can only be called from a secure origin (HTTPS) otherwise, an error will be thrown.\n *\n * @param algorithm The cryptographic hash function to use to transform a block of data into a fixed-size output.\n * @param data The value that will be used to generate a digest.\n * @return A Promise which fulfills with an ArrayBuffer representing the hashed input.\n * @example\n * ```ts\n * const array = new Uint8Array([1, 2, 3, 4, 5]);\n * const digest = await Crypto.digest(Crypto.CryptoDigestAlgorithm.SHA512, array);\n * console.log('Your digest: ' + digest);\n * ```\n */\nexport function digest(algorithm: CryptoDigestAlgorithm, data: BufferSource): Promise<ArrayBuffer> {\n  return new Promise((resolve, reject) => {\n    try {\n      if (typeof ExpoCrypto.digestAsync === 'function') {\n        resolve(ExpoCrypto.digestAsync(algorithm, data));\n      } else {\n        const output = new Uint8Array(digestLengths[algorithm]);\n        ExpoCrypto.digest(algorithm, output, data);\n        resolve(output.buffer);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}