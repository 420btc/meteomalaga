{"ast":null,"code":"import _objectWithoutPropertiesLoose from\"@babel/runtime/helpers/objectWithoutPropertiesLoose\";const _excluded=[\"passwordHash\"];import AsyncStorage from'@react-native-async-storage/async-storage';import*as Crypto from\"expo-crypto\";const USERS_STORAGE_KEY='auth_users';const CURRENT_USER_KEY='auth_current_user';const SAVED_CREDENTIALS_KEY='auth_saved_credentials';const AUTH_STATE_KEY='auth_state';const USER_INDEX_KEY='auth_user_index';export const hashPassword=async password=>{const hash=await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256,password);return hash;};const getUserIndex=async()=>{try{const indexJson=await AsyncStorage.getItem(USER_INDEX_KEY);if(indexJson){return JSON.parse(indexJson);}const users=await getUsers();const index={byUsername:{},byId:{}};for(const user of users){index.byUsername[user.username.toLowerCase()]=user.userId;index.byId[user.userId]=true;}await AsyncStorage.setItem(USER_INDEX_KEY,JSON.stringify(index));return index;}catch(error){console.error('Error getting user index:',error);return{byUsername:{},byId:{}};}};const updateUserIndex=async(user,isDelete=false)=>{try{const index=await getUserIndex();if(isDelete){delete index.byUsername[user.username.toLowerCase()];delete index.byId[user.userId];}else{index.byUsername[user.username.toLowerCase()]=user.userId;index.byId[user.userId]=true;}await AsyncStorage.setItem(USER_INDEX_KEY,JSON.stringify(index));}catch(error){console.error('Error updating user index:',error);}};const usernameExists=async username=>{const index=await getUserIndex();return!!index.byUsername[username.toLowerCase()];};const userIdExists=async userId=>{const index=await getUserIndex();return!!index.byId[userId];};const getUserByUsername=async username=>{try{const index=await getUserIndex();const userId=index.byUsername[username.toLowerCase()];if(!userId){return null;}const users=await getUsers();return users.find(user=>user.userId===userId)||null;}catch(error){console.error('Error getting user by username:',error);return null;}};const getUserById=async userId=>{try{const index=await getUserIndex();if(!index.byId[userId]){return null;}const users=await getUsers();return users.find(user=>user.userId===userId)||null;}catch(error){console.error('Error getting user by ID:',error);return null;}};export const registerUser=async(username,password)=>{try{if(!username||!password){return{success:false,message:'El nombre de usuario y la contraseña son obligatorios.'};}if(username.length<3){return{success:false,message:'El nombre de usuario debe tener al menos 3 caracteres.'};}if(password.length<6){return{success:false,message:'La contraseña debe tener al menos 6 caracteres.'};}if(await usernameExists(username)){return{success:false,message:'El nombre de usuario ya existe. Por favor, elige otro.'};}const passwordHash=await hashPassword(password);const userId=`user_${Date.now()}_${Math.random().toString(36).substring(2,15)}`;const newUser={username,passwordHash,userId,createdAt:new Date().toISOString(),displayName:username,coins:100,waterDrops:0,totalBets:0,wonBets:0,avatar:`https://randomuser.me/api/portraits/lego/${Math.floor(Math.random()*8)+1}.jpg`};await saveUser(newUser);await updateUserIndex(newUser);await saveCredentials({username,password,userId,lastUsed:new Date().toISOString()});await setCurrentUser(newUser);await updateAuthState(true,userId);return{success:true,message:'¡Registro exitoso!',userId:newUser.userId,username:newUser.username};}catch(error){console.error('Error registering user:',error);return{success:false,message:'Error al registrar usuario. Por favor, inténtalo de nuevo.'};}};export const loginUser=async(username,password)=>{try{const user=await getUserByUsername(username);if(!user){return{success:false,message:'Usuario no encontrado.'};}const passwordHash=await hashPassword(password);if(passwordHash!==user.passwordHash){return{success:false,message:'Contraseña incorrecta.'};}await saveCredentials({username,password,userId:user.userId,lastUsed:new Date().toISOString()});await setCurrentUser(user);await updateAuthState(true,user.userId);return{success:true,message:'¡Inicio de sesión exitoso!',userId:user.userId,username:user.username};}catch(error){console.error('Error logging in:',error);return{success:false,message:'Error al iniciar sesión. Por favor, inténtalo de nuevo.'};}};export const logoutUser=async()=>{try{await AsyncStorage.removeItem(CURRENT_USER_KEY);await updateAuthState(false,null);}catch(error){console.error('Error logging out:',error);}};export const getCurrentUser=async()=>{try{const userJson=await AsyncStorage.getItem(CURRENT_USER_KEY);if(!userJson)return null;const user=JSON.parse(userJson);if(!(await userIdExists(user.userId))){await AsyncStorage.removeItem(CURRENT_USER_KEY);await updateAuthState(false,null);return null;}return user;}catch(error){console.error('Error getting current user:',error);return null;}};export const isLoggedIn=async()=>{try{const authState=await getAuthState();if(authState){if(authState.isAuthenticated){const user=await getCurrentUser();return user!==null;}return false;}const user=await getCurrentUser();const isAuth=user!==null;await updateAuthState(isAuth,user?.userId||null);return isAuth;}catch(error){console.error('Error checking login status:',error);return false;}};export const getUsers=async()=>{try{const usersJson=await AsyncStorage.getItem(USERS_STORAGE_KEY);return usersJson?JSON.parse(usersJson):[];}catch(error){console.error('Error getting users:',error);return[];}};export const saveUser=async user=>{try{const users=await getUsers();const existingIndex=users.findIndex(u=>u.userId===user.userId);if(existingIndex>=0){users[existingIndex]=Object.assign({},users[existingIndex],user,{passwordHash:user.passwordHash||users[existingIndex].passwordHash,createdAt:users[existingIndex].createdAt});}else{users.push(user);}await AsyncStorage.setItem(USERS_STORAGE_KEY,JSON.stringify(users));await updateUserIndex(user);}catch(error){console.error('Error saving user:',error);throw error;}};export const updateUser=async(userId,updates)=>{try{const user=await getUserById(userId);if(!user){return false;}const updatedUser=Object.assign({},user,updates,{userId:user.userId,createdAt:user.createdAt});await saveUser(updatedUser);const currentUser=await getCurrentUser();if(currentUser&&currentUser.userId===userId){await setCurrentUser(updatedUser);}return true;}catch(error){console.error('Error updating user:',error);return false;}};export const setCurrentUser=async user=>{try{await AsyncStorage.setItem(CURRENT_USER_KEY,JSON.stringify(user));}catch(error){console.error('Error setting current user:',error);throw error;}};export const saveCredentials=async credentials=>{try{const savedCredentialsJson=await AsyncStorage.getItem(SAVED_CREDENTIALS_KEY);const savedCredentials=savedCredentialsJson?JSON.parse(savedCredentialsJson):[];const existingIndex=savedCredentials.findIndex(cred=>cred.username.toLowerCase()===credentials.username.toLowerCase());if(existingIndex>=0){savedCredentials[existingIndex]=credentials;}else{savedCredentials.push(credentials);}const sortedCredentials=savedCredentials.sort((a,b)=>new Date(b.lastUsed).getTime()-new Date(a.lastUsed).getTime());await AsyncStorage.setItem(SAVED_CREDENTIALS_KEY,JSON.stringify(sortedCredentials));}catch(error){console.error('Error saving credentials:',error);}};export const getSavedCredentials=async()=>{try{const savedCredentialsJson=await AsyncStorage.getItem(SAVED_CREDENTIALS_KEY);const savedCredentials=savedCredentialsJson?JSON.parse(savedCredentialsJson):[];return savedCredentials.sort((a,b)=>new Date(b.lastUsed).getTime()-new Date(a.lastUsed).getTime());}catch(error){console.error('Error getting saved credentials:',error);return[];}};export const loginWithSavedCredentials=async username=>{try{const savedCredentials=await getSavedCredentials();const credentials=savedCredentials.find(cred=>cred.username.toLowerCase()===username.toLowerCase());if(!credentials){return{success:false,message:'No se encontraron credenciales guardadas para este usuario.'};}return await loginUser(credentials.username,credentials.password);}catch(error){console.error('Error logging in with saved credentials:',error);return{success:false,message:'Error al iniciar sesión con credenciales guardadas.'};}};export const removeSavedCredentials=async username=>{try{const savedCredentials=await getSavedCredentials();const filteredCredentials=savedCredentials.filter(cred=>cred.username.toLowerCase()!==username.toLowerCase());await AsyncStorage.setItem(SAVED_CREDENTIALS_KEY,JSON.stringify(filteredCredentials));}catch(error){console.error('Error removing saved credentials:',error);}};export const getAuthState=async()=>{try{const authStateJson=await AsyncStorage.getItem(AUTH_STATE_KEY);return authStateJson?JSON.parse(authStateJson):null;}catch(error){console.error('Error getting auth state:',error);return null;}};export const updateAuthState=async(isAuthenticated,currentUserId)=>{try{const authState={isAuthenticated,currentUserId,lastUpdated:new Date().toISOString()};await AsyncStorage.setItem(AUTH_STATE_KEY,JSON.stringify(authState));}catch(error){console.error('Error updating auth state:',error);}};export const importUsers=async(users,defaultPassword='password123')=>{try{const existingUsers=await getUsers();const passwordHash=await hashPassword(defaultPassword);let importedCount=0;const updatedUsers=[...existingUsers];for(const user of users){if((await userIdExists(user.userId))||(await usernameExists(user.username))){continue;}const newUser=Object.assign({},user,{passwordHash,createdAt:user.createdAt||new Date().toISOString()});updatedUsers.push(newUser);await updateUserIndex(newUser);importedCount++;}await AsyncStorage.setItem(USERS_STORAGE_KEY,JSON.stringify(updatedUsers));return importedCount;}catch(error){console.error('Error importing users:',error);return 0;}};export const batchRegisterUsers=async(usernames,defaultPassword='password123')=>{try{const passwordHash=await hashPassword(defaultPassword);let registeredCount=0;const newUsers=[];for(const username of usernames){if(!username.trim())continue;if(await usernameExists(username)){continue;}const userId=`user_${Date.now()}_${Math.random().toString(36).substring(2,15)}`;const newUser={username,passwordHash,userId,createdAt:new Date().toISOString(),displayName:username,coins:100,waterDrops:0,totalBets:0,wonBets:0,avatar:`https://randomuser.me/api/portraits/lego/${Math.floor(Math.random()*8)+1}.jpg`};newUsers.push(newUser);registeredCount++;}if(newUsers.length>0){const existingUsers=await getUsers();const updatedUsers=[...existingUsers,...newUsers];await AsyncStorage.setItem(USERS_STORAGE_KEY,JSON.stringify(updatedUsers));for(const user of newUsers){await updateUserIndex(user);}}return registeredCount;}catch(error){console.error('Error batch registering users:',error);return 0;}};export const exportUsers=async()=>{try{const users=await getUsers();return users.map(user=>{const safeUser=_objectWithoutPropertiesLoose(user,_excluded);return safeUser;});}catch(error){console.error('Error exporting users:',error);return[];}};export const updateUserCoins=async(userId,coins)=>{try{const user=await getUserById(userId);if(!user){return false;}const updatedUser=Object.assign({},user,{coins});await saveUser(updatedUser);const currentUser=await getCurrentUser();if(currentUser&&currentUser.userId===userId){await setCurrentUser(updatedUser);}return true;}catch(error){console.error('Error updating user coins:',error);return false;}};export const updateUserWaterDrops=async(userId,waterDrops)=>{try{const user=await getUserById(userId);if(!user){return false;}const updatedUser=Object.assign({},user,{waterDrops:(user.waterDrops||0)+waterDrops});await saveUser(updatedUser);const currentUser=await getCurrentUser();if(currentUser&&currentUser.userId===userId){await setCurrentUser(updatedUser);}return true;}catch(error){console.error('Error updating user water drops:',error);return false;}};export const updateUserAvatar=async(userId,avatarUrl)=>{try{const user=await getUserById(userId);if(!user){return false;}const updatedUser=Object.assign({},user,{avatar:avatarUrl});await saveUser(updatedUser);const currentUser=await getCurrentUser();if(currentUser&&currentUser.userId===userId){await setCurrentUser(updatedUser);}return true;}catch(error){console.error('Error updating user avatar:',error);return false;}};export const updateUserDailyReward=async(userId,lastRewardDate,streak)=>{try{const user=await getUserById(userId);if(!user){return false;}const updatedUser=Object.assign({},user,{lastDailyReward:lastRewardDate,dailyRewardStreak:streak});await saveUser(updatedUser);const currentUser=await getCurrentUser();if(currentUser&&currentUser.userId===userId){await setCurrentUser(updatedUser);}return true;}catch(error){console.error('Error updating user daily reward:',error);return false;}};export const updateUserBetStats=async(userId,wonBet)=>{try{const user=await getUserById(userId);if(!user){return false;}const updatedUser=Object.assign({},user,{totalBets:(user.totalBets||0)+1,wonBets:wonBet?(user.wonBets||0)+1:user.wonBets||0});await saveUser(updatedUser);const currentUser=await getCurrentUser();if(currentUser&&currentUser.userId===userId){await setCurrentUser(updatedUser);}return true;}catch(error){console.error('Error updating user bet stats:',error);return false;}};","map":{"version":3,"names":["AsyncStorage","Crypto","USERS_STORAGE_KEY","CURRENT_USER_KEY","SAVED_CREDENTIALS_KEY","AUTH_STATE_KEY","USER_INDEX_KEY","hashPassword","password","hash","digestStringAsync","CryptoDigestAlgorithm","SHA256","getUserIndex","indexJson","getItem","JSON","parse","users","getUsers","index","byUsername","byId","user","username","toLowerCase","userId","setItem","stringify","error","console","updateUserIndex","isDelete","usernameExists","userIdExists","getUserByUsername","find","getUserById","registerUser","success","message","length","passwordHash","Date","now","Math","random","toString","substring","newUser","createdAt","toISOString","displayName","coins","waterDrops","totalBets","wonBets","avatar","floor","saveUser","saveCredentials","lastUsed","setCurrentUser","updateAuthState","loginUser","logoutUser","removeItem","getCurrentUser","userJson","isLoggedIn","authState","getAuthState","isAuthenticated","isAuth","usersJson","existingIndex","findIndex","u","Object","assign","push","updateUser","updates","updatedUser","currentUser","credentials","savedCredentialsJson","savedCredentials","cred","sortedCredentials","sort","a","b","getTime","getSavedCredentials","loginWithSavedCredentials","removeSavedCredentials","filteredCredentials","filter","authStateJson","currentUserId","lastUpdated","importUsers","defaultPassword","existingUsers","importedCount","updatedUsers","batchRegisterUsers","usernames","registeredCount","newUsers","trim","exportUsers","map","safeUser","_objectWithoutPropertiesLoose","_excluded","updateUserCoins","updateUserWaterDrops","updateUserAvatar","avatarUrl","updateUserDailyReward","lastRewardDate","streak","lastDailyReward","dailyRewardStreak","updateUserBetStats","wonBet"],"sources":["/Users/atemjohnatem/Downloads/meteo-malaga/src/services/enhancedAuthService.ts"],"sourcesContent":["import AsyncStorage from '@react-native-async-storage/async-storage';\n// Fix import to work in Expo Snack\nimport * as Crypto from 'expo-crypto';\nimport { Platform } from 'react-native';\n\n// Constants\nconst USERS_STORAGE_KEY = 'auth_users';\nconst CURRENT_USER_KEY = 'auth_current_user';\nconst SAVED_CREDENTIALS_KEY = 'auth_saved_credentials';\nconst AUTH_STATE_KEY = 'auth_state';\nconst USER_INDEX_KEY = 'auth_user_index';\n\n// User interface\nexport interface User {\n  username: string;\n  passwordHash: string;\n  userId: string;\n  createdAt: string;\n  displayName?: string;\n  email?: string;\n  role?: string;\n  coins?: number;\n  waterDrops?: number;\n  totalBets?: number;\n  wonBets?: number;\n  avatar?: string;\n  lastDailyReward?: string;\n  dailyRewardStreak?: number;\n}\n\n// Login response interface\nexport interface LoginResponse {\n  success: boolean;\n  message: string;\n  userId?: string;\n  username?: string;\n}\n\n// Saved credentials interface\nexport interface SavedCredentials {\n  username: string;\n  password: string;\n  userId: string;\n  lastUsed: string;\n}\n\n// Auth state interface\nexport interface AuthState {\n  isAuthenticated: boolean;\n  currentUserId: string | null;\n  lastUpdated: string;\n}\n\n// User index interface for efficient lookups\ninterface UserIndex {\n  byUsername: { [username: string]: string }; // username -> userId\n  byId: { [userId: string]: boolean }; // userId -> exists\n}\n\n/**\n * Hashes a password using SHA-256\n */\nexport const hashPassword = async (password: string): Promise<string> => {\n  const hash = await Crypto.digestStringAsync(\n    Crypto.CryptoDigestAlgorithm.SHA256,\n    password\n  );\n  return hash;\n};\n\n/**\n * Gets or creates the user index for efficient lookups\n */\nconst getUserIndex = async (): Promise<UserIndex> => {\n  try {\n    const indexJson = await AsyncStorage.getItem(USER_INDEX_KEY);\n    if (indexJson) {\n      return JSON.parse(indexJson);\n    }\n    \n    // If no index exists, create one from the users\n    const users = await getUsers();\n    const index: UserIndex = { byUsername: {}, byId: {} };\n    \n    for (const user of users) {\n      index.byUsername[user.username.toLowerCase()] = user.userId;\n      index.byId[user.userId] = true;\n    }\n    \n    // Save the index\n    await AsyncStorage.setItem(USER_INDEX_KEY, JSON.stringify(index));\n    \n    return index;\n  } catch (error) {\n    console.error('Error getting user index:', error);\n    return { byUsername: {}, byId: {} };\n  }\n};\n\n/**\n * Updates the user index\n */\nconst updateUserIndex = async (user: User, isDelete: boolean = false): Promise<void> => {\n  try {\n    const index = await getUserIndex();\n    \n    if (isDelete) {\n      // Remove user from index\n      delete index.byUsername[user.username.toLowerCase()];\n      delete index.byId[user.userId];\n    } else {\n      // Add or update user in index\n      index.byUsername[user.username.toLowerCase()] = user.userId;\n      index.byId[user.userId] = true;\n    }\n    \n    await AsyncStorage.setItem(USER_INDEX_KEY, JSON.stringify(index));\n  } catch (error) {\n    console.error('Error updating user index:', error);\n  }\n};\n\n/**\n * Checks if a username exists using the index\n */\nconst usernameExists = async (username: string): Promise<boolean> => {\n  const index = await getUserIndex();\n  return !!index.byUsername[username.toLowerCase()];\n};\n\n/**\n * Checks if a user ID exists using the index\n */\nconst userIdExists = async (userId: string): Promise<boolean> => {\n  const index = await getUserIndex();\n  return !!index.byId[userId];\n};\n\n/**\n * Gets a user by username using the index\n */\nconst getUserByUsername = async (username: string): Promise<User | null> => {\n  try {\n    const index = await getUserIndex();\n    const userId = index.byUsername[username.toLowerCase()];\n    \n    if (!userId) {\n      return null;\n    }\n    \n    // Get all users and find the one with matching ID\n    const users = await getUsers();\n    return users.find(user => user.userId === userId) || null;\n  } catch (error) {\n    console.error('Error getting user by username:', error);\n    return null;\n  }\n};\n\n/**\n * Gets a user by ID\n */\nconst getUserById = async (userId: string): Promise<User | null> => {\n  try {\n    const index = await getUserIndex();\n    \n    if (!index.byId[userId]) {\n      return null;\n    }\n    \n    // Get all users and find the one with matching ID\n    const users = await getUsers();\n    return users.find(user => user.userId === userId) || null;\n  } catch (error) {\n    console.error('Error getting user by ID:', error);\n    return null;\n  }\n};\n\n/**\n * Registers a new user\n */\nexport const registerUser = async (username: string, password: string): Promise<LoginResponse> => {\n  try {\n    // Validate username and password\n    if (!username || !password) {\n      return {\n        success: false,\n        message: 'El nombre de usuario y la contraseña son obligatorios.'\n      };\n    }\n\n    if (username.length < 3) {\n      return {\n        success: false,\n        message: 'El nombre de usuario debe tener al menos 3 caracteres.'\n      };\n    }\n\n    if (password.length < 6) {\n      return {\n        success: false,\n        message: 'La contraseña debe tener al menos 6 caracteres.'\n      };\n    }\n\n    // Check if username already exists\n    if (await usernameExists(username)) {\n      return {\n        success: false,\n        message: 'El nombre de usuario ya existe. Por favor, elige otro.'\n      };\n    }\n\n    // Hash the password\n    const passwordHash = await hashPassword(password);\n    \n    // Generate a unique user ID\n    const userId = `user_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n    \n    // Create new user\n    const newUser: User = {\n      username,\n      passwordHash,\n      userId,\n      createdAt: new Date().toISOString(),\n      displayName: username, // Set displayName same as username initially\n      coins: 100, // Default coins\n      waterDrops: 0, // Default water drops\n      totalBets: 0,\n      wonBets: 0,\n      avatar: `https://randomuser.me/api/portraits/lego/${Math.floor(Math.random() * 8) + 1}.jpg`\n    };\n    \n    // Add user to storage\n    await saveUser(newUser);\n    \n    // Update user index\n    await updateUserIndex(newUser);\n    \n    // Save credentials for offline login\n    await saveCredentials({\n      username,\n      password,\n      userId,\n      lastUsed: new Date().toISOString()\n    });\n    \n    // Set as current user\n    await setCurrentUser(newUser);\n    \n    // Update auth state\n    await updateAuthState(true, userId);\n    \n    return {\n      success: true,\n      message: '¡Registro exitoso!',\n      userId: newUser.userId,\n      username: newUser.username\n    };\n  } catch (error) {\n    console.error('Error registering user:', error);\n    return {\n      success: false,\n      message: 'Error al registrar usuario. Por favor, inténtalo de nuevo.'\n    };\n  }\n};\n\n/**\n * Logs in a user\n */\nexport const loginUser = async (username: string, password: string): Promise<LoginResponse> => {\n  try {\n    // Find user by username\n    const user = await getUserByUsername(username);\n    \n    if (!user) {\n      return {\n        success: false,\n        message: 'Usuario no encontrado.'\n      };\n    }\n    \n    // Hash the provided password and compare\n    const passwordHash = await hashPassword(password);\n    \n    if (passwordHash !== user.passwordHash) {\n      return {\n        success: false,\n        message: 'Contraseña incorrecta.'\n      };\n    }\n    \n    // Save credentials for offline login\n    await saveCredentials({\n      username,\n      password,\n      userId: user.userId,\n      lastUsed: new Date().toISOString()\n    });\n    \n    // Set as current user\n    await setCurrentUser(user);\n    \n    // Update auth state\n    await updateAuthState(true, user.userId);\n    \n    return {\n      success: true,\n      message: '¡Inicio de sesión exitoso!',\n      userId: user.userId,\n      username: user.username\n    };\n  } catch (error) {\n    console.error('Error logging in:', error);\n    return {\n      success: false,\n      message: 'Error al iniciar sesión. Por favor, inténtalo de nuevo.'\n    };\n  }\n};\n\n/**\n * Logs out the current user\n */\nexport const logoutUser = async (): Promise<void> => {\n  try {\n    await AsyncStorage.removeItem(CURRENT_USER_KEY);\n    await updateAuthState(false, null);\n  } catch (error) {\n    console.error('Error logging out:', error);\n  }\n};\n\n/**\n * Gets the current logged in user\n */\nexport const getCurrentUser = async (): Promise<User | null> => {\n  try {\n    const userJson = await AsyncStorage.getItem(CURRENT_USER_KEY);\n    if (!userJson) return null;\n    \n    const user = JSON.parse(userJson);\n    \n    // Verify user exists\n    if (!(await userIdExists(user.userId))) {\n      // User no longer exists in the database\n      await AsyncStorage.removeItem(CURRENT_USER_KEY);\n      await updateAuthState(false, null);\n      return null;\n    }\n    \n    return user;\n  } catch (error) {\n    console.error('Error getting current user:', error);\n    return null;\n  }\n};\n\n/**\n * Checks if a user is logged in\n */\nexport const isLoggedIn = async (): Promise<boolean> => {\n  try {\n    // First check the auth state for a quick response\n    const authState = await getAuthState();\n    if (authState) {\n      // Verify the auth state is still valid by checking the current user\n      if (authState.isAuthenticated) {\n        const user = await getCurrentUser();\n        return user !== null;\n      }\n      return false;\n    }\n    \n    // Fallback to checking current user directly\n    const user = await getCurrentUser();\n    const isAuth = user !== null;\n    \n    // Update auth state to match\n    await updateAuthState(isAuth, user?.userId || null);\n    \n    return isAuth;\n  } catch (error) {\n    console.error('Error checking login status:', error);\n    return false;\n  }\n};\n\n/**\n * Gets all registered users\n */\nexport const getUsers = async (): Promise<User[]> => {\n  try {\n    const usersJson = await AsyncStorage.getItem(USERS_STORAGE_KEY);\n    return usersJson ? JSON.parse(usersJson) : [];\n  } catch (error) {\n    console.error('Error getting users:', error);\n    return [];\n  }\n};\n\n/**\n * Saves a user to storage\n */\nexport const saveUser = async (user: User): Promise<void> => {\n  try {\n    const users = await getUsers();\n    \n    // Check if user already exists\n    const existingIndex = users.findIndex(u => u.userId === user.userId);\n    \n    if (existingIndex >= 0) {\n      // Update existing user\n      users[existingIndex] = {\n        ...users[existingIndex],\n        ...user,\n        // Don't override these fields if they exist\n        passwordHash: user.passwordHash || users[existingIndex].passwordHash,\n        createdAt: users[existingIndex].createdAt\n      };\n    } else {\n      // Add new user\n      users.push(user);\n    }\n    \n    await AsyncStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(users));\n    \n    // Update user index\n    await updateUserIndex(user);\n  } catch (error) {\n    console.error('Error saving user:', error);\n    throw error;\n  }\n};\n\n/**\n * Updates an existing user\n */\nexport const updateUser = async (userId: string, updates: Partial<User>): Promise<boolean> => {\n  try {\n    // Get user directly\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user\n    const updatedUser: User = {\n      ...user,\n      ...updates,\n      // Don't allow these to be updated\n      userId: user.userId,\n      createdAt: user.createdAt\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user:', error);\n    return false;\n  }\n};\n\n/**\n * Sets the current logged in user\n */\nexport const setCurrentUser = async (user: User): Promise<void> => {\n  try {\n    await AsyncStorage.setItem(CURRENT_USER_KEY, JSON.stringify(user));\n  } catch (error) {\n    console.error('Error setting current user:', error);\n    throw error;\n  }\n};\n\n/**\n * Saves user credentials for offline login\n */\nexport const saveCredentials = async (credentials: SavedCredentials): Promise<void> => {\n  try {\n    // Get existing saved credentials\n    const savedCredentialsJson = await AsyncStorage.getItem(SAVED_CREDENTIALS_KEY);\n    const savedCredentials: SavedCredentials[] = savedCredentialsJson \n      ? JSON.parse(savedCredentialsJson) \n      : [];\n    \n    // Check if credentials for this username already exist\n    const existingIndex = savedCredentials.findIndex(\n      cred => cred.username.toLowerCase() === credentials.username.toLowerCase()\n    );\n    \n    if (existingIndex >= 0) {\n      // Update existing credentials\n      savedCredentials[existingIndex] = credentials;\n    } else {\n      // Add new credentials\n      savedCredentials.push(credentials);\n    }\n    \n    // Sort by last used (most recent first)\n    const sortedCredentials = savedCredentials.sort(\n      (a, b) => new Date(b.lastUsed).getTime() - new Date(a.lastUsed).getTime()\n    );\n    \n    // Save to storage (no limit on number of saved credentials)\n    await AsyncStorage.setItem(SAVED_CREDENTIALS_KEY, JSON.stringify(sortedCredentials));\n  } catch (error) {\n    console.error('Error saving credentials:', error);\n  }\n};\n\n/**\n * Gets saved credentials for offline login\n */\nexport const getSavedCredentials = async (): Promise<SavedCredentials[]> => {\n  try {\n    const savedCredentialsJson = await AsyncStorage.getItem(SAVED_CREDENTIALS_KEY);\n    const savedCredentials: SavedCredentials[] = savedCredentialsJson \n      ? JSON.parse(savedCredentialsJson) \n      : [];\n    \n    // Sort by last used (most recent first)\n    return savedCredentials.sort(\n      (a, b) => new Date(b.lastUsed).getTime() - new Date(a.lastUsed).getTime()\n    );\n  } catch (error) {\n    console.error('Error getting saved credentials:', error);\n    return [];\n  }\n};\n\n/**\n * Attempts to login with saved credentials\n */\nexport const loginWithSavedCredentials = async (username: string): Promise<LoginResponse> => {\n  try {\n    const savedCredentials = await getSavedCredentials();\n    const credentials = savedCredentials.find(\n      cred => cred.username.toLowerCase() === username.toLowerCase()\n    );\n    \n    if (!credentials) {\n      return {\n        success: false,\n        message: 'No se encontraron credenciales guardadas para este usuario.'\n      };\n    }\n    \n    // Login with saved credentials\n    return await loginUser(credentials.username, credentials.password);\n  } catch (error) {\n    console.error('Error logging in with saved credentials:', error);\n    return {\n      success: false,\n      message: 'Error al iniciar sesión con credenciales guardadas.'\n    };\n  }\n};\n\n/**\n * Removes saved credentials for a user\n */\nexport const removeSavedCredentials = async (username: string): Promise<void> => {\n  try {\n    const savedCredentials = await getSavedCredentials();\n    const filteredCredentials = savedCredentials.filter(\n      cred => cred.username.toLowerCase() !== username.toLowerCase()\n    );\n    \n    await AsyncStorage.setItem(SAVED_CREDENTIALS_KEY, JSON.stringify(filteredCredentials));\n  } catch (error) {\n    console.error('Error removing saved credentials:', error);\n  }\n};\n\n/**\n * Gets the current authentication state\n */\nexport const getAuthState = async (): Promise<AuthState | null> => {\n  try {\n    const authStateJson = await AsyncStorage.getItem(AUTH_STATE_KEY);\n    return authStateJson ? JSON.parse(authStateJson) : null;\n  } catch (error) {\n    console.error('Error getting auth state:', error);\n    return null;\n  }\n};\n\n/**\n * Updates the authentication state\n */\nexport const updateAuthState = async (isAuthenticated: boolean, currentUserId: string | null): Promise<void> => {\n  try {\n    const authState: AuthState = {\n      isAuthenticated,\n      currentUserId,\n      lastUpdated: new Date().toISOString()\n    };\n    \n    await AsyncStorage.setItem(AUTH_STATE_KEY, JSON.stringify(authState));\n  } catch (error) {\n    console.error('Error updating auth state:', error);\n  }\n};\n\n/**\n * Imports users in bulk (for scalability)\n * @param users Array of users to import\n * @returns Number of users successfully imported\n */\nexport const importUsers = async (users: Omit<User, 'passwordHash'>[], defaultPassword: string = 'password123'): Promise<number> => {\n  try {\n    const existingUsers = await getUsers();\n    const passwordHash = await hashPassword(defaultPassword);\n    \n    let importedCount = 0;\n    const updatedUsers = [...existingUsers];\n    \n    for (const user of users) {\n      // Check if user already exists using the index\n      if (await userIdExists(user.userId) || await usernameExists(user.username)) {\n        continue;\n      }\n      \n      // Add new user\n      const newUser: User = {\n        ...user,\n        passwordHash,\n        createdAt: user.createdAt || new Date().toISOString()\n      };\n      \n      updatedUsers.push(newUser);\n      \n      // Update user index\n      await updateUserIndex(newUser);\n      \n      importedCount++;\n    }\n    \n    // Save all users\n    await AsyncStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(updatedUsers));\n    \n    return importedCount;\n  } catch (error) {\n    console.error('Error importing users:', error);\n    return 0;\n  }\n};\n\n/**\n * Batch register users (for scalability)\n */\nexport const batchRegisterUsers = async (usernames: string[], defaultPassword: string = 'password123'): Promise<number> => {\n  try {\n    const passwordHash = await hashPassword(defaultPassword);\n    \n    let registeredCount = 0;\n    const newUsers: User[] = [];\n    \n    for (const username of usernames) {\n      // Skip empty usernames\n      if (!username.trim()) continue;\n      \n      // Check if username already exists\n      if (await usernameExists(username)) {\n        continue;\n      }\n      \n      // Generate a unique user ID\n      const userId = `user_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n      \n      // Create new user\n      const newUser: User = {\n        username,\n        passwordHash,\n        userId,\n        createdAt: new Date().toISOString(),\n        displayName: username,\n        coins: 100,\n        waterDrops: 0,\n        totalBets: 0,\n        wonBets: 0,\n        avatar: `https://randomuser.me/api/portraits/lego/${Math.floor(Math.random() * 8) + 1}.jpg`\n      };\n      \n      newUsers.push(newUser);\n      registeredCount++;\n    }\n    \n    // Save all new users\n    if (newUsers.length > 0) {\n      const existingUsers = await getUsers();\n      const updatedUsers = [...existingUsers, ...newUsers];\n      await AsyncStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(updatedUsers));\n      \n      // Update user index for each new user\n      for (const user of newUsers) {\n        await updateUserIndex(user);\n      }\n    }\n    \n    return registeredCount;\n  } catch (error) {\n    console.error('Error batch registering users:', error);\n    return 0;\n  }\n};\n\n/**\n * Exports all users (for backup/migration)\n */\nexport const exportUsers = async (): Promise<Omit<User, 'passwordHash'>[]> => {\n  try {\n    const users = await getUsers();\n    \n    // Remove sensitive data\n    return users.map(user => {\n      const { passwordHash, ...safeUser } = user;\n      return safeUser;\n    });\n  } catch (error) {\n    console.error('Error exporting users:', error);\n    return [];\n  }\n};\n\n/**\n * Updates user coins\n */\nexport const updateUserCoins = async (userId: string, coins: number): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user coins\n    const updatedUser: User = {\n      ...user,\n      coins\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user coins:', error);\n    return false;\n  }\n};\n\n/**\n * Updates user water drops\n */\nexport const updateUserWaterDrops = async (userId: string, waterDrops: number): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user water drops\n    const updatedUser: User = {\n      ...user,\n      waterDrops: (user.waterDrops || 0) + waterDrops\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user water drops:', error);\n    return false;\n  }\n};\n\n/**\n * Updates user avatar\n */\nexport const updateUserAvatar = async (userId: string, avatarUrl: string): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user avatar\n    const updatedUser: User = {\n      ...user,\n      avatar: avatarUrl\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user avatar:', error);\n    return false;\n  }\n};\n\n/**\n * Updates user daily reward info\n */\nexport const updateUserDailyReward = async (\n  userId: string, \n  lastRewardDate: string, \n  streak: number\n): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user daily reward info\n    const updatedUser: User = {\n      ...user,\n      lastDailyReward: lastRewardDate,\n      dailyRewardStreak: streak\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user daily reward:', error);\n    return false;\n  }\n};\n\n/**\n * Updates user bet statistics\n */\nexport const updateUserBetStats = async (userId: string, wonBet: boolean): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user bet stats\n    const updatedUser: User = {\n      ...user,\n      totalBets: (user.totalBets || 0) + 1,\n      wonBets: wonBet ? (user.wonBets || 0) + 1 : (user.wonBets || 0)\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user bet stats:', error);\n    return false;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}