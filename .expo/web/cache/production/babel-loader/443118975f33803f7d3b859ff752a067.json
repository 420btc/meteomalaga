{"ast":null,"code":"import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import _createClass from\"@babel/runtime/helpers/createClass\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _inherits from\"@babel/runtime/helpers/inherits\";import _wrapNativeSuper from\"@babel/runtime/helpers/wrapNativeSuper\";function _callSuper(t,o,e){return o=_getPrototypeOf(o),_possibleConstructorReturn(t,_isNativeReflectConstruct()?Reflect.construct(o,e||[],_getPrototypeOf(t).constructor):o.apply(t,e));}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));}catch(t){}return(_isNativeReflectConstruct=function _isNativeReflectConstruct(){return!!t;})();}import{UnavailabilityError}from'expo-modules-core';import{CryptoDigestAlgorithm,CryptoEncoding}from\"./Crypto.types\";import ExpoCrypto from\"./ExpoCrypto\";export*from\"./Crypto.types\";var CryptoError=function(_TypeError){function CryptoError(message){var _this;_classCallCheck(this,CryptoError);_this=_callSuper(this,CryptoError,[\"expo-crypto: \"+message]);_this.code='ERR_CRYPTO';return _this;}_inherits(CryptoError,_TypeError);return _createClass(CryptoError);}(_wrapNativeSuper(TypeError));function assertAlgorithm(algorithm){if(!Object.values(CryptoDigestAlgorithm).includes(algorithm)){throw new CryptoError(\"Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.\"+Object.keys(CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.'));}}function assertData(data){if(typeof data!=='string'){throw new CryptoError(\"Invalid data provided. Expected a string.\");}}function assertEncoding(encoding){if(!Object.values(CryptoEncoding).includes(encoding)){throw new CryptoError(\"Invalid encoding provided. Expected one of: CryptoEncoding.\"+Object.keys(CryptoEncoding).join(', CryptoEncoding.'));}}export function digestStringAsync(_x,_x2){return _digestStringAsync.apply(this,arguments);}function _digestStringAsync(){_digestStringAsync=_asyncToGenerator(function*(algorithm,data){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{encoding:CryptoEncoding.HEX};if(!ExpoCrypto.digestStringAsync){throw new UnavailabilityError('expo-crypto','digestStringAsync');}assertAlgorithm(algorithm);assertData(data);assertEncoding(options.encoding);return yield ExpoCrypto.digestStringAsync(algorithm,data,options);});return _digestStringAsync.apply(this,arguments);}","map":{"version":3,"names":["UnavailabilityError","CryptoDigestAlgorithm","CryptoEncoding","ExpoCrypto","CryptoError","_TypeError","message","_this","_classCallCheck","_callSuper","code","_inherits","_createClass","_wrapNativeSuper","TypeError","assertAlgorithm","algorithm","Object","values","includes","keys","join","assertData","data","assertEncoding","encoding","digestStringAsync","_x","_x2","_digestStringAsync","apply","arguments","_asyncToGenerator","options","length","undefined","HEX"],"sources":["../src/Crypto.ts"],"sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nimport ExpoCrypto from './ExpoCrypto';\n\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * The `digestStringAsync()` method of `Crypto` generates a digest of the supplied `data` string with the provided digest `algorithm`.\n * A digest is a short fixed-length value derived from some variable-length input. **Cryptographic digests** should exhibit _collision-resistance_,\n * meaning that it's very difficult to generate multiple inputs that have equal digest values.\n * You can specify the returned string format as one of `CryptoEncoding`. By default, the resolved value will be formatted as a `HEX` string.\n * On web, this method can only be called from a secure origin (https) otherwise an error will be thrown.\n *\n * @param algorithm The cryptographic hash function to use to transform a block of data into a fixed-size output.\n * @param data The value that will be used to generate a digest.\n * @param options Format of the digest string. Defaults to: `CryptoDigestOptions.HEX`.\n * @return Return a Promise which fulfills with a value representing the hashed input.\n *\n * @example\n * ```ts\n * const digest = await Crypto.digestStringAsync(\n *   Crypto.CryptoDigestAlgorithm.SHA512,\n *   'ðŸ¥“ Easy to Digest! ðŸ’™'\n * );\n * ```\n */\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n"],"mappings":"o3BAAA,OAASA,mBAAmB,KAAQ,mBAAmB,CAEvD,OAASC,qBAAqB,CAAEC,cAAc,sBAC9C,MAAO,CAAAC,UAAU,oBAEjB,4BAA+B,GAEzB,CAAAC,WAAY,UAAAC,UAAA,EAGhB,SAAAD,YAAYE,OAAe,MAAAC,KAAA,CAAAC,eAAA,MAAAJ,WAAA,EACzBG,KAAA,CAAAE,UAAA,MAAAL,WAAA,kBAAsBE,OAAO,GAAIC,KAAA,CAHnCG,IAAI,CAAG,YAAY,QAAAH,KAAA,CAInB,CAACI,SAAA,CAAAP,WAAA,CAAAC,UAAA,SAAAO,YAAA,CAAAR,WAAA,IAAAS,gBAAA,CALuBC,SAAS,GAQnC,QAAS,CAAAC,eAAeA,CAACC,SAAgC,EACvD,GAAI,CAACC,MAAM,CAACC,MAAM,CAACjB,qBAAqB,CAAC,CAACkB,QAAQ,CAACH,SAAS,CAAC,CAAE,CAC7D,KAAM,IAAI,CAAAZ,WAAW,uEACmDa,MAAM,CAACG,IAAI,CAC/EnB,qBAAqB,CACtB,CAACoB,IAAI,CAAC,mCAAmC,CAAG,CAC9C,C,CAEL,CAEA,QAAS,CAAAC,UAAUA,CAACC,IAAY,EAC9B,GAAI,MAAO,CAAAA,IAAI,GAAK,QAAQ,CAAE,CAC5B,KAAM,IAAI,CAAAnB,WAAW,4CAA4C,CAAC,C,CAEtE,CAEA,QAAS,CAAAoB,cAAcA,CAACC,QAAwB,EAC9C,GAAI,CAACR,MAAM,CAACC,MAAM,CAAChB,cAAc,CAAC,CAACiB,QAAQ,CAACM,QAAQ,CAAC,CAAE,CACrD,KAAM,IAAI,CAAArB,WAAW,+DAC2Ca,MAAM,CAACG,IAAI,CACvElB,cAAc,CACf,CAACmB,IAAI,CAAC,mBAAmB,CAAG,CAC9B,C,CAEL,CAuBA,eAAsB,CAAAK,iBAAiBA,CAAAC,EAAA,CAAAC,GAAA,SAAAC,kBAAA,CAAAC,KAAA,MAAAC,SAAA,GActC,SAAAF,mBAAA,EAAAA,kBAAA,CAAAG,iBAAA,CAdM,UACLhB,SAAgC,CAChCO,IAAY,CACmD,IAA/D,CAAAU,OAAA,CAAAF,SAAA,CAAAG,MAAA,IAAAH,SAAA,MAAAI,SAAA,CAAAJ,SAAA,IAA+B,CAAEN,QAAQ,CAAEvB,cAAc,CAACkC,GAAG,CAAE,CAE/D,GAAI,CAACjC,UAAU,CAACuB,iBAAiB,CAAE,CACjC,KAAM,IAAI,CAAA1B,mBAAmB,CAAC,aAAa,CAAE,mBAAmB,CAAC,C,CAGnEe,eAAe,CAACC,SAAS,CAAC,CAC1BM,UAAU,CAACC,IAAI,CAAC,CAChBC,cAAc,CAACS,OAAO,CAACR,QAAQ,CAAC,CAEhC,YAAa,CAAAtB,UAAU,CAACuB,iBAAiB,CAACV,SAAS,CAAEO,IAAI,CAAEU,OAAO,CAAC,CACrE,CAAC,SAAAJ,kBAAA,CAAAC,KAAA,MAAAC,SAAA","ignoreList":[]},"metadata":{},"sourceType":"module"}