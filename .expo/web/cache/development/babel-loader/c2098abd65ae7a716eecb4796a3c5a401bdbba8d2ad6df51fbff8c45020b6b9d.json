{"ast":null,"code":"import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { fetchCurrentRainData, fetchCurrentTemperatureData, fetchCurrentWindData } from \"./weatherService\";\nimport { getRainOdds, getTemperatureOdds, getWindOdds } from \"./oddsService\";\nconst LOCAL_BETS_STORAGE_KEY = 'local_bets';\nconst TEMP_BETS_COUNT_KEY = 'daily_temp_bets';\nconst WIND_BETS_TIMESTAMP_KEY = 'last_wind_bet_timestamp';\nconst WIND_BETS_COUNT_KEY = 'wind_bets_count';\nconst RAIN_BETS_COUNT_KEY = 'rain_bets_count';\nconst LAST_BET_TIMESTAMP_KEY = 'last_bet_timestamp';\nconst BET_LOCK_KEY = 'bet_lock';\nexport const addBet = async bet => {\n  try {\n    if (await isBetLocked()) {\n      console.log('Bet is locked. Waiting for unlock...');\n      const lockTimestamp = await AsyncStorage.getItem('bet_lock_timestamp');\n      if (lockTimestamp) {\n        const lockTime = new Date(lockTimestamp).getTime();\n        const now = new Date().getTime();\n        if (now - lockTime > 10000) {\n          console.log('Force unlocking bet after 10 seconds');\n          await unlockBetting();\n        } else {\n          throw new Error('Por favor, espera unos segundos antes de realizar otra apuesta');\n        }\n      } else {\n        throw new Error('Por favor, espera unos segundos antes de realizar otra apuesta');\n      }\n    }\n    await lockBetting();\n    const isTemperatureBet = bet.option === 'temperature' || bet.option === 'temp_min' || bet.option === 'temp_max';\n    const isWindBet = bet.option === 'wind_max';\n    const isRainBet = bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount';\n    console.log('Bet type check:', {\n      isTemperatureBet,\n      isWindBet,\n      isRainBet,\n      option: bet.option\n    });\n    if (isTemperatureBet) {\n      const remainingBets = await getRemainingTemperatureBets(bet.user_id || 'anonymous');\n      if (remainingBets <= 0) {\n        await unlockBetting();\n        throw new Error('Has alcanzado el límite de 2 apuestas de temperatura para hoy');\n      }\n    }\n    if (isWindBet) {\n      const remainingWindBets = await getRemainingWindBets();\n      if (remainingWindBets <= 0) {\n        await unlockBetting();\n        throw new Error('Has alcanzado el límite de 2 apuestas de viento cada 12 horas');\n      }\n    }\n    let calculatedLeverage = 1;\n    if (isRainBet && bet.option === 'rain_amount' && bet.value !== null) {\n      calculatedLeverage = getRainOdds(bet.value);\n    } else if (isTemperatureBet && bet.value !== null) {\n      calculatedLeverage = getTemperatureOdds(bet.value);\n    } else if (isWindBet && bet.value !== null) {\n      calculatedLeverage = getWindOdds(bet.value);\n    } else if (bet.option === 'rain_yes') {\n      calculatedLeverage = 3.0;\n    } else if (bet.option === 'rain_no') {\n      calculatedLeverage = 1.2;\n    }\n    const betData = Object.assign({}, bet, {\n      id: `bet_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,\n      date: bet.date || new Date().toISOString().split('T')[0],\n      option: bet.option,\n      value: bet.value,\n      coins: bet.coins,\n      leverage: calculatedLeverage,\n      timestamp: bet.timestamp || new Date().toISOString(),\n      result: bet.result || null,\n      won: bet.won || null,\n      city: bet.city || 'Málaga',\n      mode: bet.mode || 'Simple',\n      rain_mm: bet.rain_mm || null,\n      resolution_date: bet.resolution_date || (() => {\n        const betTime = new Date(bet.timestamp || new Date().toISOString());\n        const resolutionTime = new Date(betTime);\n        if (bet.option === 'wind_max') {\n          resolutionTime.setHours(resolutionTime.getHours() + 12);\n        } else {\n          resolutionTime.setHours(resolutionTime.getHours() + 24);\n        }\n        return resolutionTime.toISOString().split('T')[0];\n      })(),\n      user_id: bet.user_id || 'anonymous',\n      status: bet.status || 'pending',\n      verificationTime: (() => {\n        const now = new Date();\n        const verificationTime = new Date(now);\n        const isTemperatureBet = bet.option === 'temperature' || bet.option === 'temp_min' || bet.option === 'temp_max';\n        const isWindBet = bet.option === 'wind_max';\n        const resolutionHours = isTemperatureBet || isWindBet || bet.bet_resolution_hours === 12 ? 12 : 24;\n        verificationTime.setHours(verificationTime.getHours() + resolutionHours);\n        return verificationTime.toISOString();\n      })(),\n      verified: false\n    });\n    betData.bet_type = getBetTypeFromOption(bet.option);\n    if (bet.option === 'temp_min') {\n      betData.temp_min_c = bet.value;\n    } else if (bet.option === 'temp_max') {\n      betData.temp_max_c = bet.value;\n    } else if (bet.option === 'wind_max') {\n      betData.wind_kmh_max = bet.value;\n    }\n    if (bet.mode === 'Pro' && bet.value !== null) {\n      const margin = getMarginFromLeverage(bet.leverage);\n      betData.range_min = Math.max(-50, bet.value - margin);\n      betData.range_max = Math.min(999, bet.value + margin);\n    }\n    const existingBetsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const existingBets = existingBetsJson ? JSON.parse(existingBetsJson) : [];\n    const updatedBets = [...existingBets, betData];\n    await AsyncStorage.setItem(LOCAL_BETS_STORAGE_KEY, JSON.stringify(updatedBets));\n    if (bet.option === 'temp_min' || bet.option === 'temp_max') {\n      await incrementDailyTemperatureBetCount();\n    }\n    if (bet.option === 'wind_max') {\n      await incrementWindBetCount();\n    }\n    if (bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') {\n      await incrementRainBetCount();\n    }\n    await AsyncStorage.setItem(LAST_BET_TIMESTAMP_KEY, new Date().toISOString());\n    setTimeout(async () => {\n      await unlockBetting();\n    }, 2000);\n    return betData;\n  } catch (error) {\n    console.error('Error in addBet:', error);\n    await unlockBetting();\n    throw error;\n  }\n};\nexport const getBets = async (userId = 'anonymous') => {\n  try {\n    const betsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const allBets = betsJson ? JSON.parse(betsJson) : [];\n    const userBets = allBets.filter(bet => bet.user_id === userId);\n    return userBets.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n  } catch (error) {\n    console.error('Error in getBets:', error);\n    return [];\n  }\n};\nexport const updateBetResult = async betResult => {\n  try {\n    const betsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const bets = betsJson ? JSON.parse(betsJson) : [];\n    const betIndex = bets.findIndex(bet => bet.id === betResult.betId);\n    if (betIndex === -1) {\n      return false;\n    }\n    bets[betIndex] = Object.assign({}, bets[betIndex], {\n      result: betResult.result,\n      won: betResult.won,\n      status: betResult.won ? 'ganada' : 'perdida',\n      verified: true\n    });\n    await AsyncStorage.setItem(LOCAL_BETS_STORAGE_KEY, JSON.stringify(bets));\n    return true;\n  } catch (error) {\n    console.error('Error in updateBetResult:', error);\n    return false;\n  }\n};\nexport const evaluatePendingBets = async (userId = 'anonymous') => {\n  try {\n    const now = new Date();\n    const betsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const bets = betsJson ? JSON.parse(betsJson) : [];\n    const betsToResolve = bets.filter(bet => bet.status === 'pending' && bet.user_id === userId && !bet.verified && new Date(bet.verificationTime) <= now);\n    if (betsToResolve.length === 0) {\n      return [];\n    }\n    const currentRainAmount = await fetchCurrentRainData();\n    const currentTemperature = await fetchCurrentTemperatureData();\n    const currentWind = await fetchCurrentWindData();\n    const results = [];\n    const updatedBets = [...bets];\n    for (const bet of betsToResolve) {\n      let result = 0;\n      let won = false;\n      let margin = 0;\n      let resolution_explanation = '';\n      if (bet.bet_type === 'rain' || bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') {\n        result = currentRainAmount;\n      } else if (bet.bet_type === 'temp_min' || bet.option === 'temp_min') {\n        result = currentTemperature.min;\n      } else if (bet.bet_type === 'temp_max' || bet.option === 'temp_max') {\n        result = currentTemperature.max;\n      } else if (bet.option === 'temperature') {\n        result = currentTemperature.current;\n      } else if (bet.option === 'wind_max') {\n        result = currentWind.max;\n      }\n      if (bet.mode === 'Simple') {\n        if (bet.option === 'rain_yes') {\n          won = result > 0;\n          if (won) {\n            resolution_explanation = `¡Ganaste! Predijiste correctamente que llovería. La cantidad de lluvia registrada fue de ${result} mm.`;\n          } else {\n            resolution_explanation = `Perdiste. Predijiste que llovería, pero no se registró lluvia (0 mm).`;\n          }\n        } else if (bet.option === 'rain_no') {\n          won = result === 0;\n          if (won) {\n            resolution_explanation = `¡Ganaste! Predijiste correctamente que no llovería. No se registró lluvia (0 mm).`;\n          } else {\n            resolution_explanation = `Perdiste. Predijiste que no llovería, pero se registraron ${result} mm de lluvia.`;\n          }\n        } else if (bet.option === 'rain_amount') {\n          const betValue = bet.rain_mm !== null ? bet.rain_mm : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 0.5;\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de ${betValue} mm de lluvia estaba dentro del margen de ±0.5 mm del valor real (${result} mm).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de ${betValue} mm de lluvia difería más de ±0.5 mm del valor real (${result} mm).`;\n          }\n        } else if (bet.option === 'temp_min') {\n          const betValue = bet.temp_min_c !== null ? bet.temp_min_c : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 1.0;\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de temperatura mínima de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de temperatura mínima de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n          }\n        } else if (bet.option === 'temp_max') {\n          const betValue = bet.temp_max_c !== null ? bet.temp_max_c : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 1.0;\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de temperatura máxima de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de temperatura máxima de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n          }\n        } else if (bet.option === 'temperature') {\n          const betValue = bet.temperature_c !== null ? bet.temperature_c : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 1.0;\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de temperatura actual de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de temperatura actual de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n          }\n        } else if (bet.option === 'wind_max') {\n          const betValue = bet.wind_kmh_max !== null ? bet.wind_kmh_max : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 3.0;\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de velocidad máxima del viento de ${betValue} km/h estaba dentro del margen de ±3.0 km/h del valor real (${result} km/h).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de velocidad máxima del viento de ${betValue} km/h difería más de ±3.0 km/h del valor real (${result} km/h).`;\n          }\n        }\n      } else if (bet.mode === 'Pro') {\n        margin = getMarginFromLeverage(bet.leverage);\n        if (bet.range_min !== null && bet.range_max !== null) {\n          won = result >= bet.range_min && result <= bet.range_max;\n          if (won) {\n            resolution_explanation = `¡Ganaste! El valor real (${result}) estaba dentro del rango que predijiste (${bet.range_min} - ${bet.range_max}).`;\n          } else {\n            resolution_explanation = `Perdiste. El valor real (${result}) estaba fuera del rango que predijiste (${bet.range_min} - ${bet.range_max}).`;\n          }\n        } else {\n          let betValue = null;\n          if (bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') {\n            betValue = bet.rain_mm !== null ? bet.rain_mm : bet.value;\n          } else if (bet.option === 'temp_min') {\n            betValue = bet.temp_min_c !== null ? bet.temp_min_c : bet.value;\n          } else if (bet.option === 'temp_max') {\n            betValue = bet.temp_max_c !== null ? bet.temp_max_c : bet.value;\n          } else if (bet.option === 'temperature') {\n            betValue = bet.temperature_c !== null ? bet.temperature_c : bet.value;\n          } else if (bet.option === 'wind_max') {\n            betValue = bet.wind_kmh_max !== null ? bet.wind_kmh_max : bet.value;\n          }\n          if (betValue !== null) {\n            won = Math.abs(result - betValue) <= margin;\n            if (won) {\n              resolution_explanation = `¡Ganaste! Tu predicción de ${betValue} estaba dentro del margen de ±${margin} del valor real (${result}).`;\n            } else {\n              resolution_explanation = `Perdiste. Tu predicción de ${betValue} difería más de ±${margin} del valor real (${result}).`;\n            }\n          }\n        }\n      }\n      const betIndex = updatedBets.findIndex(b => b.id === bet.id);\n      if (betIndex !== -1) {\n        updatedBets[betIndex] = Object.assign({}, updatedBets[betIndex], {\n          result,\n          won,\n          verified: true,\n          status: won ? 'ganada' : 'perdida',\n          resolution_explanation\n        });\n      }\n      results.push({\n        betId: bet.id,\n        result,\n        won,\n        margin\n      });\n    }\n    await AsyncStorage.setItem(LOCAL_BETS_STORAGE_KEY, JSON.stringify(updatedBets));\n    return results;\n  } catch (error) {\n    console.error('Error in evaluatePendingBets:', error);\n    return [];\n  }\n};\nexport const isBettingAllowed = async betType => {\n  try {\n    if (await isBetLocked()) {\n      console.log('Betting is locked (anti-spam protection)');\n      return false;\n    }\n    if (betType === 'temperature' || betType === 'temp_min' || betType === 'temp_max') {\n      console.log('Temperature betting is always allowed');\n      return true;\n    }\n    if (betType === 'wind') {\n      const remainingWindBets = await getRemainingWindBets();\n      console.log('Wind betting check:', remainingWindBets > 0);\n      return remainingWindBets > 0;\n    }\n    if (betType === 'rain' || betType === 'rain_yes' || betType === 'rain_no' || betType === 'rain_amount') {\n      const remainingBets = await getRemainingRainBets();\n      console.log('Rain betting allowed check in isBettingAllowed:', true, 'Remaining bets:', remainingBets);\n      return remainingBets > 0;\n    }\n    console.log('General betting allowed check in isBettingAllowed:', true, 'Bet type:', betType);\n    return true;\n  } catch (error) {\n    console.error('Error checking if betting is allowed:', error);\n    return false;\n  }\n};\nexport const isTemperatureBettingAllowed = async (userId = 'anonymous') => {\n  try {\n    if (await isBetLocked()) {\n      return false;\n    }\n    const count = await getDailyTemperatureBetCount();\n    return count < 2;\n  } catch (error) {\n    console.error('Error in isTemperatureBettingAllowed:', error);\n    return false;\n  }\n};\nexport const getRemainingTemperatureBets = async (userId = 'anonymous') => {\n  try {\n    const count = await getDailyTemperatureBetCount();\n    return Math.max(0, 2 - count);\n  } catch (error) {\n    console.error('Error in getRemainingTemperatureBets:', error);\n    return 0;\n  }\n};\nexport const canPlaceWindBetNow = async () => {\n  try {\n    return (await getRemainingWindBets()) > 0;\n  } catch (error) {\n    console.error('Error checking wind bet availability:', error);\n    return false;\n  }\n};\nexport const getRemainingWindBets = async () => {\n  try {\n    await checkAndResetWindBetCount();\n    const countJson = await AsyncStorage.getItem(WIND_BETS_COUNT_KEY);\n    const countData = countJson ? JSON.parse(countJson) : {\n      count: 0,\n      timestamp: new Date().toISOString()\n    };\n    return Math.max(0, 2 - countData.count);\n  } catch (error) {\n    console.error('Error getting remaining wind bets:', error);\n    return 0;\n  }\n};\nexport const getRemainingRainBets = async () => {\n  try {\n    await checkAndResetRainBetCount();\n    const countJson = await AsyncStorage.getItem(RAIN_BETS_COUNT_KEY);\n    const countData = countJson ? JSON.parse(countJson) : {\n      count: 0,\n      timestamp: new Date().toISOString()\n    };\n    console.log('Current rain bet count data:', countData);\n    return Math.max(0, 3 - countData.count);\n  } catch (error) {\n    console.error('Error getting remaining rain bets:', error);\n    return 0;\n  }\n};\nexport const getTimeUntilNextWindBet = async () => {\n  try {\n    const remainingBets = await getRemainingWindBets();\n    if (remainingBets > 0) {\n      return 0;\n    }\n    const countJson = await AsyncStorage.getItem(WIND_BETS_COUNT_KEY);\n    if (!countJson) {\n      return 0;\n    }\n    const countData = JSON.parse(countJson);\n    const lastResetTime = new Date(countData.timestamp);\n    const nextResetTime = new Date(lastResetTime);\n    nextResetTime.setHours(nextResetTime.getHours() + 12);\n    const now = new Date();\n    if (nextResetTime <= now) {\n      return 0;\n    }\n    return Math.ceil((nextResetTime.getTime() - now.getTime()) / (1000 * 60));\n  } catch (error) {\n    console.error('Error calculating time until next wind bet:', error);\n    return 0;\n  }\n};\nconst getBetTypeFromOption = option => {\n  if (option === 'rain_yes' || option === 'rain_no' || option === 'rain_amount') {\n    return 'rain';\n  } else if (option === 'temp_min') {\n    return 'temp_min';\n  } else if (option === 'temp_max') {\n    return 'temp_max';\n  } else if (option === 'temperature') {\n    return 'temperature';\n  } else if (option === 'wind_max') {\n    return 'wind';\n  } else {\n    return 'rain';\n  }\n};\nconst getMarginFromLeverage = leverage => {\n  switch (leverage) {\n    case 2:\n      return 5;\n    case 5:\n      return 4;\n    case 10:\n      return 3;\n    case 20:\n      return 2;\n    case 50:\n      return 1;\n    case 100:\n      return 0;\n    default:\n      return 5;\n  }\n};\nexport const resolveBets = async () => {\n  try {\n    const now = new Date();\n    const yesterday = new Date(now);\n    yesterday.setDate(yesterday.getDate() - 1);\n    const betsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const bets = betsJson ? JSON.parse(betsJson) : [];\n    const pendingBets = bets.filter(bet => bet.status === 'pending' && !bet.verified && new Date(bet.verificationTime) <= now);\n    if (pendingBets.length === 0) {\n      return;\n    }\n    const currentRainAmount = await fetchCurrentRainData();\n    const currentTemperature = await fetchCurrentTemperatureData();\n    const currentWind = await fetchCurrentWindData();\n    const updatedBets = [...bets];\n    for (const bet of pendingBets) {\n      let won = false;\n      let result = 0;\n      let resolution_explanation = '';\n      if (bet.option === 'rain_amount') {\n        result = currentRainAmount;\n        const betValue = bet.rain_mm !== null ? bet.rain_mm : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 0.5;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de ${betValue} mm de lluvia estaba dentro del margen de ±0.5 mm del valor real (${result} mm).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de ${betValue} mm de lluvia difería más de ±0.5 mm del valor real (${result} mm).`;\n        }\n      } else if (bet.option === 'rain_yes') {\n        result = currentRainAmount;\n        won = result > 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que llovería. La cantidad de lluvia registrada fue de ${result} mm.`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que llovería, pero no se registró lluvia (0 mm).`;\n        }\n      } else if (bet.option === 'rain_no') {\n        result = currentRainAmount;\n        won = result === 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que no llovería. No se registró lluvia (0 mm).`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que no llovería, pero se registraron ${result} mm de lluvia.`;\n        }\n      } else if (bet.option === 'temp_min') {\n        result = currentTemperature.min;\n        const betValue = bet.temp_min_c !== null ? bet.temp_min_c : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 1.0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de temperatura mínima de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de temperatura mínima de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n        }\n      } else if (bet.option === 'temp_max') {\n        result = currentTemperature.max;\n        const betValue = bet.temp_max_c !== null ? bet.temp_max_c : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 1.0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de temperatura máxima de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de temperatura máxima de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n        }\n      } else if (bet.option === 'temperature') {\n        result = currentTemperature.current;\n        const betValue = bet.temperature_c !== null ? bet.temperature_c : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 1.0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de temperatura actual de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de temperatura actual de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n        }\n      } else if (bet.option === 'wind_max') {\n        result = currentWind.max;\n        const betValue = bet.wind_kmh_max !== null ? bet.wind_kmh_max : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 3.0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de velocidad máxima del viento de ${betValue} km/h estaba dentro del margen de ±3.0 km/h del valor real (${result} km/h).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de velocidad máxima del viento de ${betValue} km/h difería más de ±3.0 km/h del valor real (${result} km/h).`;\n        }\n      }\n      const betIndex = updatedBets.findIndex(b => b.id === bet.id);\n      if (betIndex !== -1) {\n        updatedBets[betIndex] = Object.assign({}, updatedBets[betIndex], {\n          result,\n          won,\n          verified: true,\n          status: won ? 'ganada' : 'perdida',\n          resolution_explanation\n        });\n      }\n    }\n    await AsyncStorage.setItem(LOCAL_BETS_STORAGE_KEY, JSON.stringify(updatedBets));\n  } catch (error) {\n    console.error('Error resolving bets:', error);\n  }\n};\nconst getDailyTemperatureBetCount = async () => {\n  try {\n    const today = new Date().toISOString().split('T')[0];\n    const countJson = await AsyncStorage.getItem(TEMP_BETS_COUNT_KEY);\n    const counts = countJson ? JSON.parse(countJson) : {};\n    return counts[today] || 0;\n  } catch (error) {\n    console.error('Error getting daily temperature bet count:', error);\n    return 0;\n  }\n};\nconst incrementDailyTemperatureBetCount = async () => {\n  try {\n    const today = new Date().toISOString().split('T')[0];\n    const countJson = await AsyncStorage.getItem(TEMP_BETS_COUNT_KEY);\n    const counts = countJson ? JSON.parse(countJson) : {};\n    counts[today] = (counts[today] || 0) + 1;\n    const sevenDaysAgo = new Date();\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n    const cleanedCounts = {};\n    for (const [date, count] of Object.entries(counts)) {\n      if (new Date(date) >= sevenDaysAgo) {\n        cleanedCounts[date] = count;\n      }\n    }\n    await AsyncStorage.setItem(TEMP_BETS_COUNT_KEY, JSON.stringify(cleanedCounts));\n  } catch (error) {\n    console.error('Error incrementing daily temperature bet count:', error);\n  }\n};\nconst incrementWindBetCount = async () => {\n  try {\n    await checkAndResetWindBetCount();\n    const countJson = await AsyncStorage.getItem(WIND_BETS_COUNT_KEY);\n    const countData = countJson ? JSON.parse(countJson) : {\n      count: 0,\n      timestamp: new Date().toISOString()\n    };\n    countData.count += 1;\n    await AsyncStorage.setItem(WIND_BETS_COUNT_KEY, JSON.stringify(countData));\n  } catch (error) {\n    console.error('Error incrementing wind bet count:', error);\n  }\n};\nconst checkAndResetWindBetCount = async () => {\n  try {\n    const countJson = await AsyncStorage.getItem(WIND_BETS_COUNT_KEY);\n    if (!countJson) return;\n    const countData = JSON.parse(countJson);\n    const lastTimestamp = new Date(countData.timestamp);\n    const now = new Date();\n    const hoursDiff = (now.getTime() - lastTimestamp.getTime()) / (1000 * 60 * 60);\n    if (hoursDiff >= 12) {\n      await AsyncStorage.setItem(WIND_BETS_COUNT_KEY, JSON.stringify({\n        count: 0,\n        timestamp: now.toISOString()\n      }));\n    }\n  } catch (error) {\n    console.error('Error checking and resetting wind bet count:', error);\n  }\n};\nconst incrementRainBetCount = async () => {\n  try {\n    await checkAndResetRainBetCount();\n    const countJson = await AsyncStorage.getItem(RAIN_BETS_COUNT_KEY);\n    const countData = countJson ? JSON.parse(countJson) : {\n      count: 0,\n      timestamp: new Date().toISOString()\n    };\n    countData.count += 1;\n    console.log('Incrementing rain bet count to:', countData.count);\n    await AsyncStorage.setItem(RAIN_BETS_COUNT_KEY, JSON.stringify(countData));\n  } catch (error) {\n    console.error('Error incrementing rain bet count:', error);\n  }\n};\nconst checkAndResetRainBetCount = async () => {\n  try {\n    const countJson = await AsyncStorage.getItem(RAIN_BETS_COUNT_KEY);\n    if (!countJson) return;\n    const countData = JSON.parse(countJson);\n    const lastTimestamp = new Date(countData.timestamp);\n    const now = new Date();\n    const lastDate = lastTimestamp.toISOString().split('T')[0];\n    const currentDate = now.toISOString().split('T')[0];\n    if (lastDate !== currentDate) {\n      console.log('Resetting rain bet count - new day');\n      await AsyncStorage.setItem(RAIN_BETS_COUNT_KEY, JSON.stringify({\n        count: 0,\n        timestamp: now.toISOString()\n      }));\n    }\n  } catch (error) {\n    console.error('Error checking and resetting rain bet count:', error);\n  }\n};\nconst lockBetting = async () => {\n  try {\n    await AsyncStorage.setItem(BET_LOCK_KEY, 'locked');\n    await AsyncStorage.setItem('bet_lock_timestamp', new Date().toISOString());\n  } catch (error) {\n    console.error('Error locking betting:', error);\n  }\n};\nconst unlockBetting = async () => {\n  try {\n    await AsyncStorage.removeItem(BET_LOCK_KEY);\n    await AsyncStorage.removeItem('bet_lock_timestamp');\n  } catch (error) {\n    console.error('Error unlocking betting:', error);\n  }\n};\nconst isBetLocked = async () => {\n  try {\n    const lockStatus = await AsyncStorage.getItem(BET_LOCK_KEY);\n    return lockStatus === 'locked';\n  } catch (error) {\n    console.error('Error checking bet lock status:', error);\n    return false;\n  }\n};\nexport const resetAllBetCounters = async () => {\n  try {\n    console.log('Resetting all bet counters');\n    const today = new Date().toISOString().split('T')[0];\n    const tempCounts = {\n      [today]: 0\n    };\n    await AsyncStorage.setItem(TEMP_BETS_COUNT_KEY, JSON.stringify(tempCounts));\n    await AsyncStorage.setItem(WIND_BETS_COUNT_KEY, JSON.stringify({\n      count: 0,\n      timestamp: new Date().toISOString()\n    }));\n    await AsyncStorage.setItem(RAIN_BETS_COUNT_KEY, JSON.stringify({\n      count: 0,\n      timestamp: new Date().toISOString()\n    }));\n    await unlockBetting();\n    console.log('All bet counters have been reset');\n  } catch (error) {\n    console.error('Error resetting bet counters:', error);\n  }\n};\nexport const getOdds = getRainOdds;\nexport const getTemperatureOddsWrapper = (temp, isMin) => {\n  return getTemperatureOdds(temp);\n};\nexport { getWindOdds };","map":{"version":3,"names":["AsyncStorage","fetchCurrentRainData","fetchCurrentTemperatureData","fetchCurrentWindData","getRainOdds","getTemperatureOdds","getWindOdds","LOCAL_BETS_STORAGE_KEY","TEMP_BETS_COUNT_KEY","WIND_BETS_TIMESTAMP_KEY","WIND_BETS_COUNT_KEY","RAIN_BETS_COUNT_KEY","LAST_BET_TIMESTAMP_KEY","BET_LOCK_KEY","addBet","bet","isBetLocked","console","log","lockTimestamp","getItem","lockTime","Date","getTime","now","unlockBetting","Error","lockBetting","isTemperatureBet","option","isWindBet","isRainBet","remainingBets","getRemainingTemperatureBets","user_id","remainingWindBets","getRemainingWindBets","calculatedLeverage","value","betData","Object","assign","id","Math","random","toString","substring","date","toISOString","split","coins","leverage","timestamp","result","won","city","mode","rain_mm","resolution_date","betTime","resolutionTime","setHours","getHours","status","verificationTime","resolutionHours","bet_resolution_hours","verified","bet_type","getBetTypeFromOption","temp_min_c","temp_max_c","wind_kmh_max","margin","getMarginFromLeverage","range_min","max","range_max","min","existingBetsJson","existingBets","JSON","parse","updatedBets","setItem","stringify","incrementDailyTemperatureBetCount","incrementWindBetCount","incrementRainBetCount","setTimeout","error","getBets","userId","betsJson","allBets","userBets","filter","sort","a","b","updateBetResult","betResult","bets","betIndex","findIndex","betId","evaluatePendingBets","betsToResolve","length","currentRainAmount","currentTemperature","currentWind","results","resolution_explanation","current","betValue","abs","temperature_c","push","isBettingAllowed","betType","getRemainingRainBets","isTemperatureBettingAllowed","count","getDailyTemperatureBetCount","canPlaceWindBetNow","checkAndResetWindBetCount","countJson","countData","checkAndResetRainBetCount","getTimeUntilNextWindBet","lastResetTime","nextResetTime","ceil","resolveBets","yesterday","setDate","getDate","pendingBets","today","counts","sevenDaysAgo","cleanedCounts","entries","lastTimestamp","hoursDiff","lastDate","currentDate","removeItem","lockStatus","resetAllBetCounters","tempCounts","getOdds","getTemperatureOddsWrapper","temp","isMin"],"sources":["/Users/atemjohnatem/Downloads/meteo-malaga/src/services/localSupabaseService.ts"],"sourcesContent":["import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { Bet, BetResult, BetStatus, BetOption } from '../types/weather';\nimport { fetchCurrentRainData, fetchCurrentTemperatureData, fetchCurrentWindData, isWithinBettingWindow, isWithinBettingWindowSync } from './weatherService';\nimport { getRainOdds, getTemperatureOdds, getWindOdds } from './oddsService';\n\n// Constants\nconst LOCAL_BETS_STORAGE_KEY = 'local_bets';\nconst TEMP_BETS_COUNT_KEY = 'daily_temp_bets';\nconst WIND_BETS_TIMESTAMP_KEY = 'last_wind_bet_timestamp';\nconst WIND_BETS_COUNT_KEY = 'wind_bets_count';\nconst RAIN_BETS_COUNT_KEY = 'rain_bets_count';\nconst LAST_BET_TIMESTAMP_KEY = 'last_bet_timestamp';\nconst BET_LOCK_KEY = 'bet_lock';\n\n// Function to add a new bet (replaces addBetToSupabase)\nexport const addBet = async (bet: Bet): Promise<Bet | null> => {\n  try {\n    // Prevent rapid consecutive bets (anti-spam protection)\n    if (await isBetLocked()) {\n      console.log('Bet is locked. Waiting for unlock...');\n      // Force unlock if it's been locked for more than 10 seconds\n      const lockTimestamp = await AsyncStorage.getItem('bet_lock_timestamp');\n      if (lockTimestamp) {\n        const lockTime = new Date(lockTimestamp).getTime();\n        const now = new Date().getTime();\n        if (now - lockTime > 10000) { // 10 seconds\n          console.log('Force unlocking bet after 10 seconds');\n          await unlockBetting();\n        } else {\n          throw new Error('Por favor, espera unos segundos antes de realizar otra apuesta');\n        }\n      } else {\n        throw new Error('Por favor, espera unos segundos antes de realizar otra apuesta');\n      }\n    }\n    \n    // Lock betting temporarily to prevent rapid consecutive bets\n    await lockBetting();\n    \n    // Check if betting is allowed based on bet type\n    const isTemperatureBet = bet.option === 'temperature' || bet.option === 'temp_min' || bet.option === 'temp_max';\n    const isWindBet = bet.option === 'wind_max';\n    const isRainBet = bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount';\n    \n    console.log('Bet type check:', { isTemperatureBet, isWindBet, isRainBet, option: bet.option });\n    \n    // For temperature bets, check daily limit\n    if (isTemperatureBet) {\n      const remainingBets = await getRemainingTemperatureBets(bet.user_id || 'anonymous');\n      if (remainingBets <= 0) {\n        // Unlock betting before throwing error\n        await unlockBetting();\n        throw new Error('Has alcanzado el límite de 2 apuestas de temperatura para hoy');\n      }\n    }\n    \n    // For wind bets, check 12-hour limit\n    if (isWindBet) {\n      const remainingWindBets = await getRemainingWindBets();\n      if (remainingWindBets <= 0) {\n        // Unlock betting before throwing error\n        await unlockBetting();\n        throw new Error('Has alcanzado el límite de 2 apuestas de viento cada 12 horas');\n      }\n    }\n    \n    // Calculate appropriate odds based on bet type and value\n    let calculatedLeverage = 1;\n    if (isRainBet && bet.option === 'rain_amount' && bet.value !== null) {\n      calculatedLeverage = getRainOdds(bet.value);\n    } else if (isTemperatureBet && bet.value !== null) {\n      calculatedLeverage = getTemperatureOdds(bet.value);\n    } else if (isWindBet && bet.value !== null) {\n      calculatedLeverage = getWindOdds(bet.value);\n    } else if (bet.option === 'rain_yes') {\n      calculatedLeverage = 3.0; // Fixed odds for \"will rain\" bets\n    } else if (bet.option === 'rain_no') {\n      calculatedLeverage = 1.2; // Fixed odds for \"won't rain\" bets\n    }\n    \n    // Prepare the bet data\n    const betData: Bet = {\n      ...bet,\n      id: `bet_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,\n      date: bet.date || new Date().toISOString().split('T')[0],\n      option: bet.option,\n      value: bet.value,\n      coins: bet.coins,\n      leverage: calculatedLeverage, // Use calculated odds\n      timestamp: bet.timestamp || new Date().toISOString(),\n      result: bet.result || null,\n      won: bet.won || null,\n      city: bet.city || 'Málaga',\n      mode: bet.mode || 'Simple',\n      rain_mm: bet.rain_mm || null,\n      resolution_date: bet.resolution_date || (() => {\n        // If no resolution date, set to 24h after the bet timestamp\n        const betTime = new Date(bet.timestamp || new Date().toISOString());\n        const resolutionTime = new Date(betTime);\n        \n        // Set resolution time based on bet type\n        if (bet.option === 'wind_max') {\n          resolutionTime.setHours(resolutionTime.getHours() + 12);\n        } else {\n          resolutionTime.setHours(resolutionTime.getHours() + 24);\n        }\n        \n        return resolutionTime.toISOString().split('T')[0];\n      })(),\n      user_id: bet.user_id || 'anonymous',\n      status: bet.status || 'pending',\n      verificationTime: (() => {\n        // Create verification time (24 hours from now by default, 12 hours for temperature and wind bets)\n        const now = new Date();\n        const verificationTime = new Date(now);\n        \n        // Set verification time based on bet type\n        const isTemperatureBet = bet.option === 'temperature' || bet.option === 'temp_min' || bet.option === 'temp_max';\n        const isWindBet = bet.option === 'wind_max';\n        const resolutionHours = isTemperatureBet || isWindBet || bet.bet_resolution_hours === 12 ? 12 : 24;\n        \n        verificationTime.setHours(verificationTime.getHours() + resolutionHours);\n        return verificationTime.toISOString();\n      })(),\n      verified: false\n    };\n\n    // Set bet type\n    betData.bet_type = getBetTypeFromOption(bet.option);\n    \n    // Set temperature values if applicable\n    if (bet.option === 'temp_min') {\n      betData.temp_min_c = bet.value;\n    } else if (bet.option === 'temp_max') {\n      betData.temp_max_c = bet.value;\n    } else if (bet.option === 'wind_max') {\n      betData.wind_kmh_max = bet.value;\n    }\n    \n    // Set range values for Pro mode\n    if (bet.mode === 'Pro' && bet.value !== null) {\n      const margin = getMarginFromLeverage(bet.leverage);\n      betData.range_min = Math.max(-50, bet.value - margin);\n      betData.range_max = Math.min(999, bet.value + margin);\n    }\n\n    // Get existing bets\n    const existingBetsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const existingBets: Bet[] = existingBetsJson ? JSON.parse(existingBetsJson) : [];\n    \n    // Add new bet\n    const updatedBets = [...existingBets, betData];\n    \n    // Save updated bets\n    await AsyncStorage.setItem(LOCAL_BETS_STORAGE_KEY, JSON.stringify(updatedBets));\n\n    // If it's a temperature bet, update the daily count\n    if (bet.option === 'temp_min' || bet.option === 'temp_max') {\n      await incrementDailyTemperatureBetCount();\n    }\n    \n    // If it's a wind bet, update the count\n    if (bet.option === 'wind_max') {\n      await incrementWindBetCount();\n    }\n    \n    // If it's a rain bet, update the count\n    if (bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') {\n      await incrementRainBetCount();\n    }\n    \n    // Store last bet timestamp for rate limiting\n    await AsyncStorage.setItem(LAST_BET_TIMESTAMP_KEY, new Date().toISOString());\n    \n    // Unlock betting after successful bet\n    setTimeout(async () => {\n      await unlockBetting();\n    }, 2000);\n\n    return betData;\n  } catch (error) {\n    console.error('Error in addBet:', error);\n    // Make sure to unlock betting in case of error\n    await unlockBetting();\n    throw error;\n  }\n};\n\n// Function to get all bets (replaces getBetsFromSupabase)\nexport const getBets = async (userId: string = 'anonymous'): Promise<Bet[]> => {\n  try {\n    const betsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const allBets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n    \n    // Filter by user ID\n    const userBets = allBets.filter(bet => bet.user_id === userId);\n    \n    // Sort by timestamp (newest first)\n    return userBets.sort((a, b) => \n      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n    );\n  } catch (error) {\n    console.error('Error in getBets:', error);\n    return [];\n  }\n};\n\n// Function to update bet result (replaces updateBetResultInSupabase)\nexport const updateBetResult = async (betResult: BetResult): Promise<boolean> => {\n  try {\n    const betsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const bets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n    \n    // Find the bet to update\n    const betIndex = bets.findIndex(bet => bet.id === betResult.betId);\n    \n    if (betIndex === -1) {\n      return false;\n    }\n    \n    // Update the bet\n    bets[betIndex] = {\n      ...bets[betIndex],\n      result: betResult.result,\n      won: betResult.won,\n      status: betResult.won ? 'ganada' : 'perdida',\n      verified: true\n    };\n    \n    // Save updated bets\n    await AsyncStorage.setItem(LOCAL_BETS_STORAGE_KEY, JSON.stringify(bets));\n    \n    return true;\n  } catch (error) {\n    console.error('Error in updateBetResult:', error);\n    return false;\n  }\n};\n\n// Function to evaluate pending bets (replaces evaluatePendingBets)\nexport const evaluatePendingBets = async (userId: string = 'anonymous'): Promise<BetResult[]> => {\n  try {\n    // Get current date and time\n    const now = new Date();\n    \n    // Get all bets\n    const betsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const bets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n    \n    // Filter pending bets for the user that should be resolved now\n    const betsToResolve = bets.filter(bet => \n      bet.status === 'pending' && \n      bet.user_id === userId && \n      !bet.verified && \n      new Date(bet.verificationTime) <= now\n    );\n    \n    if (betsToResolve.length === 0) {\n      return [];\n    }\n    \n    // Get current weather data\n    const currentRainAmount = await fetchCurrentRainData();\n    const currentTemperature = await fetchCurrentTemperatureData();\n    const currentWind = await fetchCurrentWindData();\n    \n    // Evaluate each bet\n    const results: BetResult[] = [];\n    const updatedBets = [...bets];\n    \n    for (const bet of betsToResolve) {\n      let result = 0;\n      let won = false;\n      let margin = 0;\n      let resolution_explanation = '';\n      \n      // Determine the actual result based on bet type\n      if (bet.bet_type === 'rain' || bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') {\n        result = currentRainAmount;\n      } else if (bet.bet_type === 'temp_min' || bet.option === 'temp_min') {\n        result = currentTemperature.min;\n      } else if (bet.bet_type === 'temp_max' || bet.option === 'temp_max') {\n        result = currentTemperature.max;\n      } else if (bet.option === 'temperature') {\n        result = currentTemperature.current;\n      } else if (bet.option === 'wind_max') {\n        result = currentWind.max;\n      }\n      \n      // Determine if bet is won based on bet type and mode\n      if (bet.mode === 'Simple') {\n        // Simple mode: exact match\n        if (bet.option === 'rain_yes') {\n          won = result > 0;\n          if (won) {\n            resolution_explanation = `¡Ganaste! Predijiste correctamente que llovería. La cantidad de lluvia registrada fue de ${result} mm.`;\n          } else {\n            resolution_explanation = `Perdiste. Predijiste que llovería, pero no se registró lluvia (0 mm).`;\n          }\n        } else if (bet.option === 'rain_no') {\n          won = result === 0;\n          if (won) {\n            resolution_explanation = `¡Ganaste! Predijiste correctamente que no llovería. No se registró lluvia (0 mm).`;\n          } else {\n            resolution_explanation = `Perdiste. Predijiste que no llovería, pero se registraron ${result} mm de lluvia.`;\n          }\n        } else if (bet.option === 'rain_amount') {\n          const betValue = bet.rain_mm !== null ? bet.rain_mm : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 0.5; // Win if within ±0.5mm\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de ${betValue} mm de lluvia estaba dentro del margen de ±0.5 mm del valor real (${result} mm).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de ${betValue} mm de lluvia difería más de ±0.5 mm del valor real (${result} mm).`;\n          }\n        } else if (bet.option === 'temp_min') {\n          const betValue = bet.temp_min_c !== null ? bet.temp_min_c : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 1.0; // Win if within ±1.0°C\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de temperatura mínima de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de temperatura mínima de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n          }\n        } else if (bet.option === 'temp_max') {\n          const betValue = bet.temp_max_c !== null ? bet.temp_max_c : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 1.0; // Win if within ±1.0°C\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de temperatura máxima de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de temperatura máxima de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n          }\n        } else if (bet.option === 'temperature') {\n          const betValue = bet.temperature_c !== null ? bet.temperature_c : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 1.0; // Win if within ±1.0°C\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de temperatura actual de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de temperatura actual de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n          }\n        } else if (bet.option === 'wind_max') {\n          const betValue = bet.wind_kmh_max !== null ? bet.wind_kmh_max : bet.value;\n          won = Math.abs((betValue || 0) - result) <= 3.0; // Win if within ±3.0 km/h\n          if (won) {\n            resolution_explanation = `¡Ganaste! Tu predicción de velocidad máxima del viento de ${betValue} km/h estaba dentro del margen de ±3.0 km/h del valor real (${result} km/h).`;\n          } else {\n            resolution_explanation = `Perdiste. Tu predicción de velocidad máxima del viento de ${betValue} km/h difería más de ±3.0 km/h del valor real (${result} km/h).`;\n          }\n        }\n      } else if (bet.mode === 'Pro') {\n        // Pro mode: within margin based on leverage\n        margin = getMarginFromLeverage(bet.leverage);\n        \n        // Check if result is within range\n        if (bet.range_min !== null && bet.range_max !== null) {\n          won = result >= bet.range_min && result <= bet.range_max;\n          if (won) {\n            resolution_explanation = `¡Ganaste! El valor real (${result}) estaba dentro del rango que predijiste (${bet.range_min} - ${bet.range_max}).`;\n          } else {\n            resolution_explanation = `Perdiste. El valor real (${result}) estaba fuera del rango que predijiste (${bet.range_min} - ${bet.range_max}).`;\n          }\n        } else {\n          // Fallback to checking if the value is within margin of the target\n          let betValue = null;\n          \n          if (bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') {\n            betValue = bet.rain_mm !== null ? bet.rain_mm : bet.value;\n          } else if (bet.option === 'temp_min') {\n            betValue = bet.temp_min_c !== null ? bet.temp_min_c : bet.value;\n          } else if (bet.option === 'temp_max') {\n            betValue = bet.temp_max_c !== null ? bet.temp_max_c : bet.value;\n          } else if (bet.option === 'temperature') {\n            betValue = bet.temperature_c !== null ? bet.temperature_c : bet.value;\n          } else if (bet.option === 'wind_max') {\n            betValue = bet.wind_kmh_max !== null ? bet.wind_kmh_max : bet.value;\n          }\n          \n          if (betValue !== null) {\n            won = Math.abs(result - betValue) <= margin;\n            if (won) {\n              resolution_explanation = `¡Ganaste! Tu predicción de ${betValue} estaba dentro del margen de ±${margin} del valor real (${result}).`;\n            } else {\n              resolution_explanation = `Perdiste. Tu predicción de ${betValue} difería más de ±${margin} del valor real (${result}).`;\n            }\n          }\n        }\n      }\n      \n      // Find the bet in the array and update it\n      const betIndex = updatedBets.findIndex(b => b.id === bet.id);\n      if (betIndex !== -1) {\n        updatedBets[betIndex] = {\n          ...updatedBets[betIndex],\n          result,\n          won,\n          verified: true,\n          status: won ? 'ganada' : 'perdida',\n          resolution_explanation\n        };\n      }\n      \n      // Add to results\n      results.push({\n        betId: bet.id,\n        result,\n        won,\n        margin\n      });\n    }\n    \n    // Save updated bets\n    await AsyncStorage.setItem(LOCAL_BETS_STORAGE_KEY, JSON.stringify(updatedBets));\n    \n    return results;\n  } catch (error) {\n    console.error('Error in evaluatePendingBets:', error);\n    return [];\n  }\n};\n\n// Function to check if betting is allowed\nexport const isBettingAllowed = async (betType?: string): Promise<boolean> => {\n  try {\n    // Check if betting is locked (anti-spam protection)\n    if (await isBetLocked()) {\n      console.log('Betting is locked (anti-spam protection)');\n      return false;\n    }\n    \n    // Temperature bets are allowed at any time\n    if (betType === 'temperature' || betType === 'temp_min' || betType === 'temp_max') {\n      console.log('Temperature betting is always allowed');\n      return true;\n    }\n    \n    // Wind bets are allowed at any time but limited to twice per 12 hours\n    if (betType === 'wind') {\n      const remainingWindBets = await getRemainingWindBets();\n      console.log('Wind betting check:', remainingWindBets > 0);\n      return remainingWindBets > 0;\n    }\n    \n    // Rain bets are allowed at any time but limited to 3 bets per window\n    if (betType === 'rain' || betType === 'rain_yes' || betType === 'rain_no' || betType === 'rain_amount') {\n      const remainingBets = await getRemainingRainBets();\n      console.log('Rain betting allowed check in isBettingAllowed:', true, 'Remaining bets:', remainingBets);\n      return remainingBets > 0;\n    }\n    \n    // All other bet types are allowed\n    console.log('General betting allowed check in isBettingAllowed:', true, 'Bet type:', betType);\n    return true;\n  } catch (error) {\n    console.error('Error checking if betting is allowed:', error);\n    return false;\n  }\n};\n\n// Function to check if temperature betting is allowed (max 2 per day)\nexport const isTemperatureBettingAllowed = async (userId: string = 'anonymous'): Promise<boolean> => {\n  try {\n    // Check if betting is locked (anti-spam protection)\n    if (await isBetLocked()) {\n      return false;\n    }\n    \n    const count = await getDailyTemperatureBetCount();\n    return count < 2;\n  } catch (error) {\n    console.error('Error in isTemperatureBettingAllowed:', error);\n    return false;\n  }\n};\n\n// Function to get remaining temperature bets for today\nexport const getRemainingTemperatureBets = async (userId: string = 'anonymous'): Promise<number> => {\n  try {\n    const count = await getDailyTemperatureBetCount();\n    return Math.max(0, 2 - count);\n  } catch (error) {\n    console.error('Error in getRemainingTemperatureBets:', error);\n    return 0;\n  }\n};\n\n// Function to check if wind betting is allowed (twice per 12 hours)\nexport const canPlaceWindBetNow = async (): Promise<boolean> => {\n  try {\n    return await getRemainingWindBets() > 0;\n  } catch (error) {\n    console.error('Error checking wind bet availability:', error);\n    return false;\n  }\n};\n\n// Function to get remaining wind bets\nexport const getRemainingWindBets = async (): Promise<number> => {\n  try {\n    // Check if we need to reset the wind bet count\n    await checkAndResetWindBetCount();\n    \n    // Get current wind bet count\n    const countJson = await AsyncStorage.getItem(WIND_BETS_COUNT_KEY);\n    const countData = countJson ? JSON.parse(countJson) : { count: 0, timestamp: new Date().toISOString() };\n    \n    // Maximum 2 wind bets per 12 hours\n    return Math.max(0, 2 - countData.count);\n  } catch (error) {\n    console.error('Error getting remaining wind bets:', error);\n    return 0;\n  }\n};\n\n// Function to get remaining rain bets\nexport const getRemainingRainBets = async (): Promise<number> => {\n  try {\n    // Check if we need to reset the rain bet count\n    await checkAndResetRainBetCount();\n    \n    // Get current rain bet count\n    const countJson = await AsyncStorage.getItem(RAIN_BETS_COUNT_KEY);\n    const countData = countJson ? JSON.parse(countJson) : { count: 0, timestamp: new Date().toISOString() };\n    \n    console.log('Current rain bet count data:', countData);\n    \n    // Maximum 3 rain bets per window\n    return Math.max(0, 3 - countData.count);\n  } catch (error) {\n    console.error('Error getting remaining rain bets:', error);\n    return 0;\n  }\n};\n\n// Function to get time until next wind bet is allowed\nexport const getTimeUntilNextWindBet = async (): Promise<number> => {\n  try {\n    // If there are remaining bets, return 0\n    const remainingBets = await getRemainingWindBets();\n    if (remainingBets > 0) {\n      return 0;\n    }\n    \n    // Get the timestamp of the last wind bet count reset\n    const countJson = await AsyncStorage.getItem(WIND_BETS_COUNT_KEY);\n    if (!countJson) {\n      return 0;\n    }\n    \n    const countData = JSON.parse(countJson);\n    const lastResetTime = new Date(countData.timestamp);\n    const nextResetTime = new Date(lastResetTime);\n    nextResetTime.setHours(nextResetTime.getHours() + 12);\n    \n    const now = new Date();\n    if (nextResetTime <= now) {\n      return 0;\n    }\n    \n    // Return minutes until next reset\n    return Math.ceil((nextResetTime.getTime() - now.getTime()) / (1000 * 60));\n  } catch (error) {\n    console.error('Error calculating time until next wind bet:', error);\n    return 0;\n  }\n};\n\n// Helper function to get bet type from option\nconst getBetTypeFromOption = (option: BetOption): string => {\n  if (option === 'rain_yes' || option === 'rain_no' || option === 'rain_amount') {\n    return 'rain';\n  } else if (option === 'temp_min') {\n    return 'temp_min';\n  } else if (option === 'temp_max') {\n    return 'temp_max';\n  } else if (option === 'temperature') {\n    return 'temperature';\n  } else if (option === 'wind_max') {\n    return 'wind';\n  } else {\n    return 'rain'; // Default\n  }\n};\n\n// Helper function to get margin from leverage\nconst getMarginFromLeverage = (leverage: number): number => {\n  switch (leverage) {\n    case 2: return 5;\n    case 5: return 4;\n    case 10: return 3;\n    case 20: return 2;\n    case 50: return 1;\n    case 100: return 0;\n    default: return 5;\n  }\n};\n\n// Function to resolve bets\nexport const resolveBets = async (): Promise<void> => {\n  try {\n    const now = new Date();\n    const yesterday = new Date(now);\n    yesterday.setDate(yesterday.getDate() - 1);\n    \n    // Get all bets\n    const betsJson = await AsyncStorage.getItem(LOCAL_BETS_STORAGE_KEY);\n    const bets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n    \n    // Filter pending bets with resolution dates in the past\n    const pendingBets = bets.filter(bet => \n      bet.status === 'pending' && \n      !bet.verified &&\n      new Date(bet.verificationTime) <= now\n    );\n    \n    if (pendingBets.length === 0) {\n      return;\n    }\n    \n    // Get current weather data\n    const currentRainAmount = await fetchCurrentRainData();\n    const currentTemperature = await fetchCurrentTemperatureData();\n    const currentWind = await fetchCurrentWindData();\n    \n    // Process each bet\n    const updatedBets = [...bets];\n    \n    for (const bet of pendingBets) {\n      // Determine if bet is won\n      let won = false;\n      let result = 0;\n      let resolution_explanation = '';\n      \n      if (bet.option === 'rain_amount') {\n        result = currentRainAmount;\n        const betValue = bet.rain_mm !== null ? bet.rain_mm : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 0.5; // Win if within ±0.5mm\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de ${betValue} mm de lluvia estaba dentro del margen de ±0.5 mm del valor real (${result} mm).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de ${betValue} mm de lluvia difería más de ±0.5 mm del valor real (${result} mm).`;\n        }\n      } else if (bet.option === 'rain_yes') {\n        result = currentRainAmount;\n        won = result > 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que llovería. La cantidad de lluvia registrada fue de ${result} mm.`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que llovería, pero no se registró lluvia (0 mm).`;\n        }\n      } else if (bet.option === 'rain_no') {\n        result = currentRainAmount;\n        won = result === 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que no llovería. No se registró lluvia (0 mm).`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que no llovería, pero se registraron ${result} mm de lluvia.`;\n        }\n      } else if (bet.option === 'temp_min') {\n        result = currentTemperature.min;\n        const betValue = bet.temp_min_c !== null ? bet.temp_min_c : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 1.0; // Win if within ±1.0°C\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de temperatura mínima de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de temperatura mínima de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n        }\n      } else if (bet.option === 'temp_max') {\n        result = currentTemperature.max;\n        const betValue = bet.temp_max_c !== null ? bet.temp_max_c : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 1.0; // Win if within ±1.0°C\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de temperatura máxima de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de temperatura máxima de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n        }\n      } else if (bet.option === 'temperature') {\n        result = currentTemperature.current;\n        const betValue = bet.temperature_c !== null ? bet.temperature_c : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 1.0; // Win if within ±1.0°C\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de temperatura actual de ${betValue}°C estaba dentro del margen de ±1.0°C del valor real (${result}°C).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de temperatura actual de ${betValue}°C difería más de ±1.0°C del valor real (${result}°C).`;\n        }\n      } else if (bet.option === 'wind_max') {\n        result = currentWind.max;\n        const betValue = bet.wind_kmh_max !== null ? bet.wind_kmh_max : bet.value;\n        won = Math.abs((betValue || 0) - result) <= 3.0; // Win if within ±3.0 km/h\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de velocidad máxima del viento de ${betValue} km/h estaba dentro del margen de ±3.0 km/h del valor real (${result} km/h).`;\n        } else {\n          resolution_explanation = `Perdiste. Tu predicción de velocidad máxima del viento de ${betValue} km/h difería más de ±3.0 km/h del valor real (${result} km/h).`;\n        }\n      }\n      \n      // Find the bet in the array and update it\n      const betIndex = updatedBets.findIndex(b => b.id === bet.id);\n      if (betIndex !== -1) {\n        updatedBets[betIndex] = {\n          ...updatedBets[betIndex],\n          result,\n          won,\n          verified: true,\n          status: won ? 'ganada' : 'perdida',\n          resolution_explanation\n        };\n      }\n    }\n    \n    // Save updated bets\n    await AsyncStorage.setItem(LOCAL_BETS_STORAGE_KEY, JSON.stringify(updatedBets));\n  } catch (error) {\n    console.error('Error resolving bets:', error);\n  }\n};\n\n// Helper functions for daily temperature bet count\nconst getDailyTemperatureBetCount = async (): Promise<number> => {\n  try {\n    const today = new Date().toISOString().split('T')[0];\n    const countJson = await AsyncStorage.getItem(TEMP_BETS_COUNT_KEY);\n    const counts = countJson ? JSON.parse(countJson) : {};\n    \n    return counts[today] || 0;\n  } catch (error) {\n    console.error('Error getting daily temperature bet count:', error);\n    return 0;\n  }\n};\n\nconst incrementDailyTemperatureBetCount = async (): Promise<void> => {\n  try {\n    const today = new Date().toISOString().split('T')[0];\n    const countJson = await AsyncStorage.getItem(TEMP_BETS_COUNT_KEY);\n    const counts = countJson ? JSON.parse(countJson) : {};\n    \n    counts[today] = (counts[today] || 0) + 1;\n    \n    // Clean up old entries (keep only last 7 days)\n    const sevenDaysAgo = new Date();\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n    \n    const cleanedCounts = {};\n    for (const [date, count] of Object.entries(counts)) {\n      if (new Date(date) >= sevenDaysAgo) {\n        cleanedCounts[date] = count;\n      }\n    }\n    \n    await AsyncStorage.setItem(TEMP_BETS_COUNT_KEY, JSON.stringify(cleanedCounts));\n  } catch (error) {\n    console.error('Error incrementing daily temperature bet count:', error);\n  }\n};\n\n// Helper functions for wind bet count\nconst incrementWindBetCount = async (): Promise<void> => {\n  try {\n    // Check if we need to reset the count first\n    await checkAndResetWindBetCount();\n    \n    // Get current count\n    const countJson = await AsyncStorage.getItem(WIND_BETS_COUNT_KEY);\n    const countData = countJson ? JSON.parse(countJson) : { count: 0, timestamp: new Date().toISOString() };\n    \n    // Increment count\n    countData.count += 1;\n    \n    // Save updated count\n    await AsyncStorage.setItem(WIND_BETS_COUNT_KEY, JSON.stringify(countData));\n  } catch (error) {\n    console.error('Error incrementing wind bet count:', error);\n  }\n};\n\nconst checkAndResetWindBetCount = async (): Promise<void> => {\n  try {\n    const countJson = await AsyncStorage.getItem(WIND_BETS_COUNT_KEY);\n    if (!countJson) return;\n    \n    const countData = JSON.parse(countJson);\n    const lastTimestamp = new Date(countData.timestamp);\n    const now = new Date();\n    \n    // Calculate hours difference\n    const hoursDiff = (now.getTime() - lastTimestamp.getTime()) / (1000 * 60 * 60);\n    \n    // Reset if 12 hours have passed\n    if (hoursDiff >= 12) {\n      await AsyncStorage.setItem(WIND_BETS_COUNT_KEY, JSON.stringify({ count: 0, timestamp: now.toISOString() }));\n    }\n  } catch (error) {\n    console.error('Error checking and resetting wind bet count:', error);\n  }\n};\n\n// Helper functions for rain bet count\nconst incrementRainBetCount = async (): Promise<void> => {\n  try {\n    // Check if we need to reset the count first\n    await checkAndResetRainBetCount();\n    \n    // Get current count\n    const countJson = await AsyncStorage.getItem(RAIN_BETS_COUNT_KEY);\n    const countData = countJson ? JSON.parse(countJson) : { count: 0, timestamp: new Date().toISOString() };\n    \n    // Increment count\n    countData.count += 1;\n    \n    console.log('Incrementing rain bet count to:', countData.count);\n    \n    // Save updated count\n    await AsyncStorage.setItem(RAIN_BETS_COUNT_KEY, JSON.stringify(countData));\n  } catch (error) {\n    console.error('Error incrementing rain bet count:', error);\n  }\n};\n\nconst checkAndResetRainBetCount = async (): Promise<void> => {\n  try {\n    const countJson = await AsyncStorage.getItem(RAIN_BETS_COUNT_KEY);\n    if (!countJson) return;\n    \n    const countData = JSON.parse(countJson);\n    const lastTimestamp = new Date(countData.timestamp);\n    const now = new Date();\n    \n    // Check if we're in a new betting window\n    const lastDate = lastTimestamp.toISOString().split('T')[0];\n    const currentDate = now.toISOString().split('T')[0];\n    \n    // Reset if date has changed\n    if (lastDate !== currentDate) {\n      console.log('Resetting rain bet count - new day');\n      await AsyncStorage.setItem(RAIN_BETS_COUNT_KEY, JSON.stringify({ count: 0, timestamp: now.toISOString() }));\n    }\n  } catch (error) {\n    console.error('Error checking and resetting rain bet count:', error);\n  }\n};\n\n// Anti-spam protection functions\nconst lockBetting = async (): Promise<void> => {\n  try {\n    await AsyncStorage.setItem(BET_LOCK_KEY, 'locked');\n    await AsyncStorage.setItem('bet_lock_timestamp', new Date().toISOString());\n  } catch (error) {\n    console.error('Error locking betting:', error);\n  }\n};\n\nconst unlockBetting = async (): Promise<void> => {\n  try {\n    await AsyncStorage.removeItem(BET_LOCK_KEY);\n    await AsyncStorage.removeItem('bet_lock_timestamp');\n  } catch (error) {\n    console.error('Error unlocking betting:', error);\n  }\n};\n\nconst isBetLocked = async (): Promise<boolean> => {\n  try {\n    const lockStatus = await AsyncStorage.getItem(BET_LOCK_KEY);\n    return lockStatus === 'locked';\n  } catch (error) {\n    console.error('Error checking bet lock status:', error);\n    return false;\n  }\n};\n\n// New function to reset all bet counters (for debugging)\nexport const resetAllBetCounters = async (): Promise<void> => {\n  try {\n    console.log('Resetting all bet counters');\n    \n    // Reset temperature bet count\n    const today = new Date().toISOString().split('T')[0];\n    const tempCounts = { [today]: 0 };\n    await AsyncStorage.setItem(TEMP_BETS_COUNT_KEY, JSON.stringify(tempCounts));\n    \n    // Reset wind bet count\n    await AsyncStorage.setItem(WIND_BETS_COUNT_KEY, JSON.stringify({ count: 0, timestamp: new Date().toISOString() }));\n    \n    // Reset rain bet count\n    await AsyncStorage.setItem(RAIN_BETS_COUNT_KEY, JSON.stringify({ count: 0, timestamp: new Date().toISOString() }));\n    \n    // Unlock betting\n    await unlockBetting();\n    \n    console.log('All bet counters have been reset');\n  } catch (error) {\n    console.error('Error resetting bet counters:', error);\n  }\n};\n\n// Export the old odds functions for backward compatibility\nexport const getOdds = getRainOdds;\nexport const getTemperatureOddsWrapper: any = (temp: number, isMin: boolean): number => {\n  return getTemperatureOdds(temp);\n};\n// Export the getWindOdds function directly to maintain compatibility\nexport { getWindOdds };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}