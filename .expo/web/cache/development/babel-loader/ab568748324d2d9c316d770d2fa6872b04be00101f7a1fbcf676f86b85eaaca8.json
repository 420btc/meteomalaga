{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"passwordHash\"];\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport * as Crypto from \"expo-crypto\";\nconst USERS_STORAGE_KEY = 'auth_users';\nconst CURRENT_USER_KEY = 'auth_current_user';\nconst SAVED_CREDENTIALS_KEY = 'auth_saved_credentials';\nconst AUTH_STATE_KEY = 'auth_state';\nconst USER_INDEX_KEY = 'auth_user_index';\nexport const hashPassword = async password => {\n  const hash = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, password);\n  return hash;\n};\nconst getUserIndex = async () => {\n  try {\n    const indexJson = await AsyncStorage.getItem(USER_INDEX_KEY);\n    if (indexJson) {\n      return JSON.parse(indexJson);\n    }\n    const users = await getUsers();\n    const index = {\n      byUsername: {},\n      byId: {}\n    };\n    for (const user of users) {\n      index.byUsername[user.username.toLowerCase()] = user.userId;\n      index.byId[user.userId] = true;\n    }\n    await AsyncStorage.setItem(USER_INDEX_KEY, JSON.stringify(index));\n    return index;\n  } catch (error) {\n    console.error('Error getting user index:', error);\n    return {\n      byUsername: {},\n      byId: {}\n    };\n  }\n};\nconst updateUserIndex = async (user, isDelete = false) => {\n  try {\n    const index = await getUserIndex();\n    if (isDelete) {\n      delete index.byUsername[user.username.toLowerCase()];\n      delete index.byId[user.userId];\n    } else {\n      index.byUsername[user.username.toLowerCase()] = user.userId;\n      index.byId[user.userId] = true;\n    }\n    await AsyncStorage.setItem(USER_INDEX_KEY, JSON.stringify(index));\n  } catch (error) {\n    console.error('Error updating user index:', error);\n  }\n};\nconst usernameExists = async username => {\n  const index = await getUserIndex();\n  return !!index.byUsername[username.toLowerCase()];\n};\nconst userIdExists = async userId => {\n  const index = await getUserIndex();\n  return !!index.byId[userId];\n};\nconst getUserByUsername = async username => {\n  try {\n    const index = await getUserIndex();\n    const userId = index.byUsername[username.toLowerCase()];\n    if (!userId) {\n      return null;\n    }\n    const users = await getUsers();\n    return users.find(user => user.userId === userId) || null;\n  } catch (error) {\n    console.error('Error getting user by username:', error);\n    return null;\n  }\n};\nconst getUserById = async userId => {\n  try {\n    const index = await getUserIndex();\n    if (!index.byId[userId]) {\n      return null;\n    }\n    const users = await getUsers();\n    return users.find(user => user.userId === userId) || null;\n  } catch (error) {\n    console.error('Error getting user by ID:', error);\n    return null;\n  }\n};\nexport const registerUser = async (username, password) => {\n  try {\n    if (!username || !password) {\n      return {\n        success: false,\n        message: 'El nombre de usuario y la contraseña son obligatorios.'\n      };\n    }\n    if (username.length < 3) {\n      return {\n        success: false,\n        message: 'El nombre de usuario debe tener al menos 3 caracteres.'\n      };\n    }\n    if (password.length < 6) {\n      return {\n        success: false,\n        message: 'La contraseña debe tener al menos 6 caracteres.'\n      };\n    }\n    if (await usernameExists(username)) {\n      return {\n        success: false,\n        message: 'El nombre de usuario ya existe. Por favor, elige otro.'\n      };\n    }\n    const passwordHash = await hashPassword(password);\n    const userId = `user_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n    const newUser = {\n      username,\n      passwordHash,\n      userId,\n      createdAt: new Date().toISOString(),\n      displayName: username,\n      coins: 100,\n      waterDrops: 0,\n      totalBets: 0,\n      wonBets: 0,\n      avatar: `https://randomuser.me/api/portraits/lego/${Math.floor(Math.random() * 8) + 1}.jpg`\n    };\n    await saveUser(newUser);\n    await updateUserIndex(newUser);\n    await saveCredentials({\n      username,\n      password,\n      userId,\n      lastUsed: new Date().toISOString()\n    });\n    await setCurrentUser(newUser);\n    await updateAuthState(true, userId);\n    return {\n      success: true,\n      message: '¡Registro exitoso!',\n      userId: newUser.userId,\n      username: newUser.username\n    };\n  } catch (error) {\n    console.error('Error registering user:', error);\n    return {\n      success: false,\n      message: 'Error al registrar usuario. Por favor, inténtalo de nuevo.'\n    };\n  }\n};\nexport const loginUser = async (username, password) => {\n  try {\n    const user = await getUserByUsername(username);\n    if (!user) {\n      return {\n        success: false,\n        message: 'Usuario no encontrado.'\n      };\n    }\n    const passwordHash = await hashPassword(password);\n    if (passwordHash !== user.passwordHash) {\n      return {\n        success: false,\n        message: 'Contraseña incorrecta.'\n      };\n    }\n    await saveCredentials({\n      username,\n      password,\n      userId: user.userId,\n      lastUsed: new Date().toISOString()\n    });\n    await setCurrentUser(user);\n    await updateAuthState(true, user.userId);\n    return {\n      success: true,\n      message: '¡Inicio de sesión exitoso!',\n      userId: user.userId,\n      username: user.username\n    };\n  } catch (error) {\n    console.error('Error logging in:', error);\n    return {\n      success: false,\n      message: 'Error al iniciar sesión. Por favor, inténtalo de nuevo.'\n    };\n  }\n};\nexport const logoutUser = async () => {\n  try {\n    await AsyncStorage.removeItem(CURRENT_USER_KEY);\n    await updateAuthState(false, null);\n  } catch (error) {\n    console.error('Error logging out:', error);\n  }\n};\nexport const getCurrentUser = async () => {\n  try {\n    const userJson = await AsyncStorage.getItem(CURRENT_USER_KEY);\n    if (!userJson) return null;\n    const user = JSON.parse(userJson);\n    if (!(await userIdExists(user.userId))) {\n      await AsyncStorage.removeItem(CURRENT_USER_KEY);\n      await updateAuthState(false, null);\n      return null;\n    }\n    return user;\n  } catch (error) {\n    console.error('Error getting current user:', error);\n    return null;\n  }\n};\nexport const isLoggedIn = async () => {\n  try {\n    const authState = await getAuthState();\n    if (authState) {\n      if (authState.isAuthenticated) {\n        const user = await getCurrentUser();\n        return user !== null;\n      }\n      return false;\n    }\n    const user = await getCurrentUser();\n    const isAuth = user !== null;\n    await updateAuthState(isAuth, user?.userId || null);\n    return isAuth;\n  } catch (error) {\n    console.error('Error checking login status:', error);\n    return false;\n  }\n};\nexport const getUsers = async () => {\n  try {\n    const usersJson = await AsyncStorage.getItem(USERS_STORAGE_KEY);\n    return usersJson ? JSON.parse(usersJson) : [];\n  } catch (error) {\n    console.error('Error getting users:', error);\n    return [];\n  }\n};\nexport const saveUser = async user => {\n  try {\n    const users = await getUsers();\n    const existingIndex = users.findIndex(u => u.userId === user.userId);\n    if (existingIndex >= 0) {\n      users[existingIndex] = Object.assign({}, users[existingIndex], user, {\n        passwordHash: user.passwordHash || users[existingIndex].passwordHash,\n        createdAt: users[existingIndex].createdAt\n      });\n    } else {\n      users.push(user);\n    }\n    await AsyncStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(users));\n    await updateUserIndex(user);\n  } catch (error) {\n    console.error('Error saving user:', error);\n    throw error;\n  }\n};\nexport const updateUser = async (userId, updates) => {\n  try {\n    const user = await getUserById(userId);\n    if (!user) {\n      return false;\n    }\n    const updatedUser = Object.assign({}, user, updates, {\n      userId: user.userId,\n      createdAt: user.createdAt\n    });\n    await saveUser(updatedUser);\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    return true;\n  } catch (error) {\n    console.error('Error updating user:', error);\n    return false;\n  }\n};\nexport const setCurrentUser = async user => {\n  try {\n    await AsyncStorage.setItem(CURRENT_USER_KEY, JSON.stringify(user));\n  } catch (error) {\n    console.error('Error setting current user:', error);\n    throw error;\n  }\n};\nexport const saveCredentials = async credentials => {\n  try {\n    const savedCredentialsJson = await AsyncStorage.getItem(SAVED_CREDENTIALS_KEY);\n    const savedCredentials = savedCredentialsJson ? JSON.parse(savedCredentialsJson) : [];\n    const existingIndex = savedCredentials.findIndex(cred => cred.username.toLowerCase() === credentials.username.toLowerCase());\n    if (existingIndex >= 0) {\n      savedCredentials[existingIndex] = credentials;\n    } else {\n      savedCredentials.push(credentials);\n    }\n    const sortedCredentials = savedCredentials.sort((a, b) => new Date(b.lastUsed).getTime() - new Date(a.lastUsed).getTime());\n    await AsyncStorage.setItem(SAVED_CREDENTIALS_KEY, JSON.stringify(sortedCredentials));\n  } catch (error) {\n    console.error('Error saving credentials:', error);\n  }\n};\nexport const getSavedCredentials = async () => {\n  try {\n    const savedCredentialsJson = await AsyncStorage.getItem(SAVED_CREDENTIALS_KEY);\n    const savedCredentials = savedCredentialsJson ? JSON.parse(savedCredentialsJson) : [];\n    return savedCredentials.sort((a, b) => new Date(b.lastUsed).getTime() - new Date(a.lastUsed).getTime());\n  } catch (error) {\n    console.error('Error getting saved credentials:', error);\n    return [];\n  }\n};\nexport const loginWithSavedCredentials = async username => {\n  try {\n    const savedCredentials = await getSavedCredentials();\n    const credentials = savedCredentials.find(cred => cred.username.toLowerCase() === username.toLowerCase());\n    if (!credentials) {\n      return {\n        success: false,\n        message: 'No se encontraron credenciales guardadas para este usuario.'\n      };\n    }\n    return await loginUser(credentials.username, credentials.password);\n  } catch (error) {\n    console.error('Error logging in with saved credentials:', error);\n    return {\n      success: false,\n      message: 'Error al iniciar sesión con credenciales guardadas.'\n    };\n  }\n};\nexport const removeSavedCredentials = async username => {\n  try {\n    const savedCredentials = await getSavedCredentials();\n    const filteredCredentials = savedCredentials.filter(cred => cred.username.toLowerCase() !== username.toLowerCase());\n    await AsyncStorage.setItem(SAVED_CREDENTIALS_KEY, JSON.stringify(filteredCredentials));\n  } catch (error) {\n    console.error('Error removing saved credentials:', error);\n  }\n};\nexport const getAuthState = async () => {\n  try {\n    const authStateJson = await AsyncStorage.getItem(AUTH_STATE_KEY);\n    return authStateJson ? JSON.parse(authStateJson) : null;\n  } catch (error) {\n    console.error('Error getting auth state:', error);\n    return null;\n  }\n};\nexport const updateAuthState = async (isAuthenticated, currentUserId) => {\n  try {\n    const authState = {\n      isAuthenticated,\n      currentUserId,\n      lastUpdated: new Date().toISOString()\n    };\n    await AsyncStorage.setItem(AUTH_STATE_KEY, JSON.stringify(authState));\n  } catch (error) {\n    console.error('Error updating auth state:', error);\n  }\n};\nexport const importUsers = async (users, defaultPassword = 'password123') => {\n  try {\n    const existingUsers = await getUsers();\n    const passwordHash = await hashPassword(defaultPassword);\n    let importedCount = 0;\n    const updatedUsers = [...existingUsers];\n    for (const user of users) {\n      if ((await userIdExists(user.userId)) || (await usernameExists(user.username))) {\n        continue;\n      }\n      const newUser = Object.assign({}, user, {\n        passwordHash,\n        createdAt: user.createdAt || new Date().toISOString()\n      });\n      updatedUsers.push(newUser);\n      await updateUserIndex(newUser);\n      importedCount++;\n    }\n    await AsyncStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(updatedUsers));\n    return importedCount;\n  } catch (error) {\n    console.error('Error importing users:', error);\n    return 0;\n  }\n};\nexport const batchRegisterUsers = async (usernames, defaultPassword = 'password123') => {\n  try {\n    const passwordHash = await hashPassword(defaultPassword);\n    let registeredCount = 0;\n    const newUsers = [];\n    for (const username of usernames) {\n      if (!username.trim()) continue;\n      if (await usernameExists(username)) {\n        continue;\n      }\n      const userId = `user_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n      const newUser = {\n        username,\n        passwordHash,\n        userId,\n        createdAt: new Date().toISOString(),\n        displayName: username,\n        coins: 100,\n        waterDrops: 0,\n        totalBets: 0,\n        wonBets: 0,\n        avatar: `https://randomuser.me/api/portraits/lego/${Math.floor(Math.random() * 8) + 1}.jpg`\n      };\n      newUsers.push(newUser);\n      registeredCount++;\n    }\n    if (newUsers.length > 0) {\n      const existingUsers = await getUsers();\n      const updatedUsers = [...existingUsers, ...newUsers];\n      await AsyncStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(updatedUsers));\n      for (const user of newUsers) {\n        await updateUserIndex(user);\n      }\n    }\n    return registeredCount;\n  } catch (error) {\n    console.error('Error batch registering users:', error);\n    return 0;\n  }\n};\nexport const exportUsers = async () => {\n  try {\n    const users = await getUsers();\n    return users.map(user => {\n      const safeUser = _objectWithoutPropertiesLoose(user, _excluded);\n      return safeUser;\n    });\n  } catch (error) {\n    console.error('Error exporting users:', error);\n    return [];\n  }\n};\nexport const updateUserCoins = async (userId, coins) => {\n  try {\n    const user = await getUserById(userId);\n    if (!user) {\n      return false;\n    }\n    const updatedUser = Object.assign({}, user, {\n      coins\n    });\n    await saveUser(updatedUser);\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    return true;\n  } catch (error) {\n    console.error('Error updating user coins:', error);\n    return false;\n  }\n};\nexport const updateUserWaterDrops = async (userId, waterDrops) => {\n  try {\n    const user = await getUserById(userId);\n    if (!user) {\n      return false;\n    }\n    const updatedUser = Object.assign({}, user, {\n      waterDrops: (user.waterDrops || 0) + waterDrops\n    });\n    await saveUser(updatedUser);\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    return true;\n  } catch (error) {\n    console.error('Error updating user water drops:', error);\n    return false;\n  }\n};\nexport const updateUserAvatar = async (userId, avatarUrl) => {\n  try {\n    const user = await getUserById(userId);\n    if (!user) {\n      return false;\n    }\n    const updatedUser = Object.assign({}, user, {\n      avatar: avatarUrl\n    });\n    await saveUser(updatedUser);\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    return true;\n  } catch (error) {\n    console.error('Error updating user avatar:', error);\n    return false;\n  }\n};\nexport const updateUserDailyReward = async (userId, lastRewardDate, streak) => {\n  try {\n    const user = await getUserById(userId);\n    if (!user) {\n      return false;\n    }\n    const updatedUser = Object.assign({}, user, {\n      lastDailyReward: lastRewardDate,\n      dailyRewardStreak: streak\n    });\n    await saveUser(updatedUser);\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    return true;\n  } catch (error) {\n    console.error('Error updating user daily reward:', error);\n    return false;\n  }\n};\nexport const updateUserBetStats = async (userId, wonBet) => {\n  try {\n    const user = await getUserById(userId);\n    if (!user) {\n      return false;\n    }\n    const updatedUser = Object.assign({}, user, {\n      totalBets: (user.totalBets || 0) + 1,\n      wonBets: wonBet ? (user.wonBets || 0) + 1 : user.wonBets || 0\n    });\n    await saveUser(updatedUser);\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    return true;\n  } catch (error) {\n    console.error('Error updating user bet stats:', error);\n    return false;\n  }\n};","map":{"version":3,"names":["AsyncStorage","Crypto","USERS_STORAGE_KEY","CURRENT_USER_KEY","SAVED_CREDENTIALS_KEY","AUTH_STATE_KEY","USER_INDEX_KEY","hashPassword","password","hash","digestStringAsync","CryptoDigestAlgorithm","SHA256","getUserIndex","indexJson","getItem","JSON","parse","users","getUsers","index","byUsername","byId","user","username","toLowerCase","userId","setItem","stringify","error","console","updateUserIndex","isDelete","usernameExists","userIdExists","getUserByUsername","find","getUserById","registerUser","success","message","length","passwordHash","Date","now","Math","random","toString","substring","newUser","createdAt","toISOString","displayName","coins","waterDrops","totalBets","wonBets","avatar","floor","saveUser","saveCredentials","lastUsed","setCurrentUser","updateAuthState","loginUser","logoutUser","removeItem","getCurrentUser","userJson","isLoggedIn","authState","getAuthState","isAuthenticated","isAuth","usersJson","existingIndex","findIndex","u","Object","assign","push","updateUser","updates","updatedUser","currentUser","credentials","savedCredentialsJson","savedCredentials","cred","sortedCredentials","sort","a","b","getTime","getSavedCredentials","loginWithSavedCredentials","removeSavedCredentials","filteredCredentials","filter","authStateJson","currentUserId","lastUpdated","importUsers","defaultPassword","existingUsers","importedCount","updatedUsers","batchRegisterUsers","usernames","registeredCount","newUsers","trim","exportUsers","map","safeUser","_objectWithoutPropertiesLoose","_excluded","updateUserCoins","updateUserWaterDrops","updateUserAvatar","avatarUrl","updateUserDailyReward","lastRewardDate","streak","lastDailyReward","dailyRewardStreak","updateUserBetStats","wonBet"],"sources":["/Users/atemjohnatem/Downloads/meteo-malaga/src/services/enhancedAuthService.ts"],"sourcesContent":["import AsyncStorage from '@react-native-async-storage/async-storage';\n// Fix import to work in Expo Snack\nimport * as Crypto from 'expo-crypto';\nimport { Platform } from 'react-native';\n\n// Constants\nconst USERS_STORAGE_KEY = 'auth_users';\nconst CURRENT_USER_KEY = 'auth_current_user';\nconst SAVED_CREDENTIALS_KEY = 'auth_saved_credentials';\nconst AUTH_STATE_KEY = 'auth_state';\nconst USER_INDEX_KEY = 'auth_user_index';\n\n// User interface\nexport interface User {\n  username: string;\n  passwordHash: string;\n  userId: string;\n  createdAt: string;\n  displayName?: string;\n  email?: string;\n  role?: string;\n  coins?: number;\n  waterDrops?: number;\n  totalBets?: number;\n  wonBets?: number;\n  avatar?: string;\n  lastDailyReward?: string;\n  dailyRewardStreak?: number;\n}\n\n// Login response interface\nexport interface LoginResponse {\n  success: boolean;\n  message: string;\n  userId?: string;\n  username?: string;\n}\n\n// Saved credentials interface\nexport interface SavedCredentials {\n  username: string;\n  password: string;\n  userId: string;\n  lastUsed: string;\n}\n\n// Auth state interface\nexport interface AuthState {\n  isAuthenticated: boolean;\n  currentUserId: string | null;\n  lastUpdated: string;\n}\n\n// User index interface for efficient lookups\ninterface UserIndex {\n  byUsername: { [username: string]: string }; // username -> userId\n  byId: { [userId: string]: boolean }; // userId -> exists\n}\n\n/**\n * Hashes a password using SHA-256\n */\nexport const hashPassword = async (password: string): Promise<string> => {\n  const hash = await Crypto.digestStringAsync(\n    Crypto.CryptoDigestAlgorithm.SHA256,\n    password\n  );\n  return hash;\n};\n\n/**\n * Gets or creates the user index for efficient lookups\n */\nconst getUserIndex = async (): Promise<UserIndex> => {\n  try {\n    const indexJson = await AsyncStorage.getItem(USER_INDEX_KEY);\n    if (indexJson) {\n      return JSON.parse(indexJson);\n    }\n    \n    // If no index exists, create one from the users\n    const users = await getUsers();\n    const index: UserIndex = { byUsername: {}, byId: {} };\n    \n    for (const user of users) {\n      index.byUsername[user.username.toLowerCase()] = user.userId;\n      index.byId[user.userId] = true;\n    }\n    \n    // Save the index\n    await AsyncStorage.setItem(USER_INDEX_KEY, JSON.stringify(index));\n    \n    return index;\n  } catch (error) {\n    console.error('Error getting user index:', error);\n    return { byUsername: {}, byId: {} };\n  }\n};\n\n/**\n * Updates the user index\n */\nconst updateUserIndex = async (user: User, isDelete: boolean = false): Promise<void> => {\n  try {\n    const index = await getUserIndex();\n    \n    if (isDelete) {\n      // Remove user from index\n      delete index.byUsername[user.username.toLowerCase()];\n      delete index.byId[user.userId];\n    } else {\n      // Add or update user in index\n      index.byUsername[user.username.toLowerCase()] = user.userId;\n      index.byId[user.userId] = true;\n    }\n    \n    await AsyncStorage.setItem(USER_INDEX_KEY, JSON.stringify(index));\n  } catch (error) {\n    console.error('Error updating user index:', error);\n  }\n};\n\n/**\n * Checks if a username exists using the index\n */\nconst usernameExists = async (username: string): Promise<boolean> => {\n  const index = await getUserIndex();\n  return !!index.byUsername[username.toLowerCase()];\n};\n\n/**\n * Checks if a user ID exists using the index\n */\nconst userIdExists = async (userId: string): Promise<boolean> => {\n  const index = await getUserIndex();\n  return !!index.byId[userId];\n};\n\n/**\n * Gets a user by username using the index\n */\nconst getUserByUsername = async (username: string): Promise<User | null> => {\n  try {\n    const index = await getUserIndex();\n    const userId = index.byUsername[username.toLowerCase()];\n    \n    if (!userId) {\n      return null;\n    }\n    \n    // Get all users and find the one with matching ID\n    const users = await getUsers();\n    return users.find(user => user.userId === userId) || null;\n  } catch (error) {\n    console.error('Error getting user by username:', error);\n    return null;\n  }\n};\n\n/**\n * Gets a user by ID\n */\nconst getUserById = async (userId: string): Promise<User | null> => {\n  try {\n    const index = await getUserIndex();\n    \n    if (!index.byId[userId]) {\n      return null;\n    }\n    \n    // Get all users and find the one with matching ID\n    const users = await getUsers();\n    return users.find(user => user.userId === userId) || null;\n  } catch (error) {\n    console.error('Error getting user by ID:', error);\n    return null;\n  }\n};\n\n/**\n * Registers a new user\n */\nexport const registerUser = async (username: string, password: string): Promise<LoginResponse> => {\n  try {\n    // Validate username and password\n    if (!username || !password) {\n      return {\n        success: false,\n        message: 'El nombre de usuario y la contraseña son obligatorios.'\n      };\n    }\n\n    if (username.length < 3) {\n      return {\n        success: false,\n        message: 'El nombre de usuario debe tener al menos 3 caracteres.'\n      };\n    }\n\n    if (password.length < 6) {\n      return {\n        success: false,\n        message: 'La contraseña debe tener al menos 6 caracteres.'\n      };\n    }\n\n    // Check if username already exists\n    if (await usernameExists(username)) {\n      return {\n        success: false,\n        message: 'El nombre de usuario ya existe. Por favor, elige otro.'\n      };\n    }\n\n    // Hash the password\n    const passwordHash = await hashPassword(password);\n    \n    // Generate a unique user ID\n    const userId = `user_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n    \n    // Create new user\n    const newUser: User = {\n      username,\n      passwordHash,\n      userId,\n      createdAt: new Date().toISOString(),\n      displayName: username, // Set displayName same as username initially\n      coins: 100, // Default coins\n      waterDrops: 0, // Default water drops\n      totalBets: 0,\n      wonBets: 0,\n      avatar: `https://randomuser.me/api/portraits/lego/${Math.floor(Math.random() * 8) + 1}.jpg`\n    };\n    \n    // Add user to storage\n    await saveUser(newUser);\n    \n    // Update user index\n    await updateUserIndex(newUser);\n    \n    // Save credentials for offline login\n    await saveCredentials({\n      username,\n      password,\n      userId,\n      lastUsed: new Date().toISOString()\n    });\n    \n    // Set as current user\n    await setCurrentUser(newUser);\n    \n    // Update auth state\n    await updateAuthState(true, userId);\n    \n    return {\n      success: true,\n      message: '¡Registro exitoso!',\n      userId: newUser.userId,\n      username: newUser.username\n    };\n  } catch (error) {\n    console.error('Error registering user:', error);\n    return {\n      success: false,\n      message: 'Error al registrar usuario. Por favor, inténtalo de nuevo.'\n    };\n  }\n};\n\n/**\n * Logs in a user\n */\nexport const loginUser = async (username: string, password: string): Promise<LoginResponse> => {\n  try {\n    // Find user by username\n    const user = await getUserByUsername(username);\n    \n    if (!user) {\n      return {\n        success: false,\n        message: 'Usuario no encontrado.'\n      };\n    }\n    \n    // Hash the provided password and compare\n    const passwordHash = await hashPassword(password);\n    \n    if (passwordHash !== user.passwordHash) {\n      return {\n        success: false,\n        message: 'Contraseña incorrecta.'\n      };\n    }\n    \n    // Save credentials for offline login\n    await saveCredentials({\n      username,\n      password,\n      userId: user.userId,\n      lastUsed: new Date().toISOString()\n    });\n    \n    // Set as current user\n    await setCurrentUser(user);\n    \n    // Update auth state\n    await updateAuthState(true, user.userId);\n    \n    return {\n      success: true,\n      message: '¡Inicio de sesión exitoso!',\n      userId: user.userId,\n      username: user.username\n    };\n  } catch (error) {\n    console.error('Error logging in:', error);\n    return {\n      success: false,\n      message: 'Error al iniciar sesión. Por favor, inténtalo de nuevo.'\n    };\n  }\n};\n\n/**\n * Logs out the current user\n */\nexport const logoutUser = async (): Promise<void> => {\n  try {\n    await AsyncStorage.removeItem(CURRENT_USER_KEY);\n    await updateAuthState(false, null);\n  } catch (error) {\n    console.error('Error logging out:', error);\n  }\n};\n\n/**\n * Gets the current logged in user\n */\nexport const getCurrentUser = async (): Promise<User | null> => {\n  try {\n    const userJson = await AsyncStorage.getItem(CURRENT_USER_KEY);\n    if (!userJson) return null;\n    \n    const user = JSON.parse(userJson);\n    \n    // Verify user exists\n    if (!(await userIdExists(user.userId))) {\n      // User no longer exists in the database\n      await AsyncStorage.removeItem(CURRENT_USER_KEY);\n      await updateAuthState(false, null);\n      return null;\n    }\n    \n    return user;\n  } catch (error) {\n    console.error('Error getting current user:', error);\n    return null;\n  }\n};\n\n/**\n * Checks if a user is logged in\n */\nexport const isLoggedIn = async (): Promise<boolean> => {\n  try {\n    // First check the auth state for a quick response\n    const authState = await getAuthState();\n    if (authState) {\n      // Verify the auth state is still valid by checking the current user\n      if (authState.isAuthenticated) {\n        const user = await getCurrentUser();\n        return user !== null;\n      }\n      return false;\n    }\n    \n    // Fallback to checking current user directly\n    const user = await getCurrentUser();\n    const isAuth = user !== null;\n    \n    // Update auth state to match\n    await updateAuthState(isAuth, user?.userId || null);\n    \n    return isAuth;\n  } catch (error) {\n    console.error('Error checking login status:', error);\n    return false;\n  }\n};\n\n/**\n * Gets all registered users\n */\nexport const getUsers = async (): Promise<User[]> => {\n  try {\n    const usersJson = await AsyncStorage.getItem(USERS_STORAGE_KEY);\n    return usersJson ? JSON.parse(usersJson) : [];\n  } catch (error) {\n    console.error('Error getting users:', error);\n    return [];\n  }\n};\n\n/**\n * Saves a user to storage\n */\nexport const saveUser = async (user: User): Promise<void> => {\n  try {\n    const users = await getUsers();\n    \n    // Check if user already exists\n    const existingIndex = users.findIndex(u => u.userId === user.userId);\n    \n    if (existingIndex >= 0) {\n      // Update existing user\n      users[existingIndex] = {\n        ...users[existingIndex],\n        ...user,\n        // Don't override these fields if they exist\n        passwordHash: user.passwordHash || users[existingIndex].passwordHash,\n        createdAt: users[existingIndex].createdAt\n      };\n    } else {\n      // Add new user\n      users.push(user);\n    }\n    \n    await AsyncStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(users));\n    \n    // Update user index\n    await updateUserIndex(user);\n  } catch (error) {\n    console.error('Error saving user:', error);\n    throw error;\n  }\n};\n\n/**\n * Updates an existing user\n */\nexport const updateUser = async (userId: string, updates: Partial<User>): Promise<boolean> => {\n  try {\n    // Get user directly\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user\n    const updatedUser: User = {\n      ...user,\n      ...updates,\n      // Don't allow these to be updated\n      userId: user.userId,\n      createdAt: user.createdAt\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user:', error);\n    return false;\n  }\n};\n\n/**\n * Sets the current logged in user\n */\nexport const setCurrentUser = async (user: User): Promise<void> => {\n  try {\n    await AsyncStorage.setItem(CURRENT_USER_KEY, JSON.stringify(user));\n  } catch (error) {\n    console.error('Error setting current user:', error);\n    throw error;\n  }\n};\n\n/**\n * Saves user credentials for offline login\n */\nexport const saveCredentials = async (credentials: SavedCredentials): Promise<void> => {\n  try {\n    // Get existing saved credentials\n    const savedCredentialsJson = await AsyncStorage.getItem(SAVED_CREDENTIALS_KEY);\n    const savedCredentials: SavedCredentials[] = savedCredentialsJson \n      ? JSON.parse(savedCredentialsJson) \n      : [];\n    \n    // Check if credentials for this username already exist\n    const existingIndex = savedCredentials.findIndex(\n      cred => cred.username.toLowerCase() === credentials.username.toLowerCase()\n    );\n    \n    if (existingIndex >= 0) {\n      // Update existing credentials\n      savedCredentials[existingIndex] = credentials;\n    } else {\n      // Add new credentials\n      savedCredentials.push(credentials);\n    }\n    \n    // Sort by last used (most recent first)\n    const sortedCredentials = savedCredentials.sort(\n      (a, b) => new Date(b.lastUsed).getTime() - new Date(a.lastUsed).getTime()\n    );\n    \n    // Save to storage (no limit on number of saved credentials)\n    await AsyncStorage.setItem(SAVED_CREDENTIALS_KEY, JSON.stringify(sortedCredentials));\n  } catch (error) {\n    console.error('Error saving credentials:', error);\n  }\n};\n\n/**\n * Gets saved credentials for offline login\n */\nexport const getSavedCredentials = async (): Promise<SavedCredentials[]> => {\n  try {\n    const savedCredentialsJson = await AsyncStorage.getItem(SAVED_CREDENTIALS_KEY);\n    const savedCredentials: SavedCredentials[] = savedCredentialsJson \n      ? JSON.parse(savedCredentialsJson) \n      : [];\n    \n    // Sort by last used (most recent first)\n    return savedCredentials.sort(\n      (a, b) => new Date(b.lastUsed).getTime() - new Date(a.lastUsed).getTime()\n    );\n  } catch (error) {\n    console.error('Error getting saved credentials:', error);\n    return [];\n  }\n};\n\n/**\n * Attempts to login with saved credentials\n */\nexport const loginWithSavedCredentials = async (username: string): Promise<LoginResponse> => {\n  try {\n    const savedCredentials = await getSavedCredentials();\n    const credentials = savedCredentials.find(\n      cred => cred.username.toLowerCase() === username.toLowerCase()\n    );\n    \n    if (!credentials) {\n      return {\n        success: false,\n        message: 'No se encontraron credenciales guardadas para este usuario.'\n      };\n    }\n    \n    // Login with saved credentials\n    return await loginUser(credentials.username, credentials.password);\n  } catch (error) {\n    console.error('Error logging in with saved credentials:', error);\n    return {\n      success: false,\n      message: 'Error al iniciar sesión con credenciales guardadas.'\n    };\n  }\n};\n\n/**\n * Removes saved credentials for a user\n */\nexport const removeSavedCredentials = async (username: string): Promise<void> => {\n  try {\n    const savedCredentials = await getSavedCredentials();\n    const filteredCredentials = savedCredentials.filter(\n      cred => cred.username.toLowerCase() !== username.toLowerCase()\n    );\n    \n    await AsyncStorage.setItem(SAVED_CREDENTIALS_KEY, JSON.stringify(filteredCredentials));\n  } catch (error) {\n    console.error('Error removing saved credentials:', error);\n  }\n};\n\n/**\n * Gets the current authentication state\n */\nexport const getAuthState = async (): Promise<AuthState | null> => {\n  try {\n    const authStateJson = await AsyncStorage.getItem(AUTH_STATE_KEY);\n    return authStateJson ? JSON.parse(authStateJson) : null;\n  } catch (error) {\n    console.error('Error getting auth state:', error);\n    return null;\n  }\n};\n\n/**\n * Updates the authentication state\n */\nexport const updateAuthState = async (isAuthenticated: boolean, currentUserId: string | null): Promise<void> => {\n  try {\n    const authState: AuthState = {\n      isAuthenticated,\n      currentUserId,\n      lastUpdated: new Date().toISOString()\n    };\n    \n    await AsyncStorage.setItem(AUTH_STATE_KEY, JSON.stringify(authState));\n  } catch (error) {\n    console.error('Error updating auth state:', error);\n  }\n};\n\n/**\n * Imports users in bulk (for scalability)\n * @param users Array of users to import\n * @returns Number of users successfully imported\n */\nexport const importUsers = async (users: Omit<User, 'passwordHash'>[], defaultPassword: string = 'password123'): Promise<number> => {\n  try {\n    const existingUsers = await getUsers();\n    const passwordHash = await hashPassword(defaultPassword);\n    \n    let importedCount = 0;\n    const updatedUsers = [...existingUsers];\n    \n    for (const user of users) {\n      // Check if user already exists using the index\n      if (await userIdExists(user.userId) || await usernameExists(user.username)) {\n        continue;\n      }\n      \n      // Add new user\n      const newUser: User = {\n        ...user,\n        passwordHash,\n        createdAt: user.createdAt || new Date().toISOString()\n      };\n      \n      updatedUsers.push(newUser);\n      \n      // Update user index\n      await updateUserIndex(newUser);\n      \n      importedCount++;\n    }\n    \n    // Save all users\n    await AsyncStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(updatedUsers));\n    \n    return importedCount;\n  } catch (error) {\n    console.error('Error importing users:', error);\n    return 0;\n  }\n};\n\n/**\n * Batch register users (for scalability)\n */\nexport const batchRegisterUsers = async (usernames: string[], defaultPassword: string = 'password123'): Promise<number> => {\n  try {\n    const passwordHash = await hashPassword(defaultPassword);\n    \n    let registeredCount = 0;\n    const newUsers: User[] = [];\n    \n    for (const username of usernames) {\n      // Skip empty usernames\n      if (!username.trim()) continue;\n      \n      // Check if username already exists\n      if (await usernameExists(username)) {\n        continue;\n      }\n      \n      // Generate a unique user ID\n      const userId = `user_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n      \n      // Create new user\n      const newUser: User = {\n        username,\n        passwordHash,\n        userId,\n        createdAt: new Date().toISOString(),\n        displayName: username,\n        coins: 100,\n        waterDrops: 0,\n        totalBets: 0,\n        wonBets: 0,\n        avatar: `https://randomuser.me/api/portraits/lego/${Math.floor(Math.random() * 8) + 1}.jpg`\n      };\n      \n      newUsers.push(newUser);\n      registeredCount++;\n    }\n    \n    // Save all new users\n    if (newUsers.length > 0) {\n      const existingUsers = await getUsers();\n      const updatedUsers = [...existingUsers, ...newUsers];\n      await AsyncStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(updatedUsers));\n      \n      // Update user index for each new user\n      for (const user of newUsers) {\n        await updateUserIndex(user);\n      }\n    }\n    \n    return registeredCount;\n  } catch (error) {\n    console.error('Error batch registering users:', error);\n    return 0;\n  }\n};\n\n/**\n * Exports all users (for backup/migration)\n */\nexport const exportUsers = async (): Promise<Omit<User, 'passwordHash'>[]> => {\n  try {\n    const users = await getUsers();\n    \n    // Remove sensitive data\n    return users.map(user => {\n      const { passwordHash, ...safeUser } = user;\n      return safeUser;\n    });\n  } catch (error) {\n    console.error('Error exporting users:', error);\n    return [];\n  }\n};\n\n/**\n * Updates user coins\n */\nexport const updateUserCoins = async (userId: string, coins: number): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user coins\n    const updatedUser: User = {\n      ...user,\n      coins\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user coins:', error);\n    return false;\n  }\n};\n\n/**\n * Updates user water drops\n */\nexport const updateUserWaterDrops = async (userId: string, waterDrops: number): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user water drops\n    const updatedUser: User = {\n      ...user,\n      waterDrops: (user.waterDrops || 0) + waterDrops\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user water drops:', error);\n    return false;\n  }\n};\n\n/**\n * Updates user avatar\n */\nexport const updateUserAvatar = async (userId: string, avatarUrl: string): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user avatar\n    const updatedUser: User = {\n      ...user,\n      avatar: avatarUrl\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user avatar:', error);\n    return false;\n  }\n};\n\n/**\n * Updates user daily reward info\n */\nexport const updateUserDailyReward = async (\n  userId: string, \n  lastRewardDate: string, \n  streak: number\n): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user daily reward info\n    const updatedUser: User = {\n      ...user,\n      lastDailyReward: lastRewardDate,\n      dailyRewardStreak: streak\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user daily reward:', error);\n    return false;\n  }\n};\n\n/**\n * Updates user bet statistics\n */\nexport const updateUserBetStats = async (userId: string, wonBet: boolean): Promise<boolean> => {\n  try {\n    const user = await getUserById(userId);\n    \n    if (!user) {\n      return false;\n    }\n    \n    // Update user bet stats\n    const updatedUser: User = {\n      ...user,\n      totalBets: (user.totalBets || 0) + 1,\n      wonBets: wonBet ? (user.wonBets || 0) + 1 : (user.wonBets || 0)\n    };\n    \n    // Save updated user\n    await saveUser(updatedUser);\n    \n    // If this is the current user, update current user as well\n    const currentUser = await getCurrentUser();\n    if (currentUser && currentUser.userId === userId) {\n      await setCurrentUser(updatedUser);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error updating user bet stats:', error);\n    return false;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}