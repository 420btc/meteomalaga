{"ast":null,"code":"import { fetchCurrentRainData, fetchCurrentTemperatureData, fetchCurrentWindData } from \"../services/weatherService\";\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nconst PENDING_RESOLUTIONS_KEY = 'pendingBetResolutions';\nconst FAILED_RESOLUTIONS_KEY = 'failedBetResolutions';\nconst RESOLUTION_ATTEMPTS_KEY = 'betResolutionAttempts';\nconst MAX_RETRY_ATTEMPTS = 5;\nexport const resolveBet = async bet => {\n  try {\n    if (bet.verified || bet.status === 'ganada' || bet.status === 'perdida') {\n      return bet;\n    }\n    const now = new Date();\n    const verificationTime = new Date(bet.verificationTime || '');\n    if (isNaN(verificationTime.getTime())) {\n      console.error('Tiempo de verificación inválido para la apuesta:', bet.id);\n      await logResolutionError(bet, 'Tiempo de verificación inválido');\n      return Object.assign({}, bet, {\n        resolution_explanation: 'No se pudo resolver: tiempo de verificación inválido. Se reintentará más tarde.'\n      });\n    }\n    if (now < verificationTime) {\n      return bet;\n    }\n    await recordResolutionAttempt(bet);\n    const [currentRainAmount, currentTemperature, currentWind] = await Promise.all([fetchCurrentRainData().catch(error => {\n      console.error('Error al obtener datos de lluvia:', error);\n      return null;\n    }), fetchCurrentTemperatureData().catch(error => {\n      console.error('Error al obtener datos de temperatura:', error);\n      return null;\n    }), fetchCurrentWindData().catch(error => {\n      console.error('Error al obtener datos de viento:', error);\n      return null;\n    })]);\n    if ((bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') && currentRainAmount === null || (bet.option === 'temp_min' || bet.option === 'temp_max' || bet.option === 'temperature') && currentTemperature === null || bet.option === 'wind_max' && currentWind === null) {\n      console.error('Datos meteorológicos no disponibles para resolver la apuesta:', bet.id);\n      await addToPendingResolutions(bet);\n      return Object.assign({}, bet, {\n        resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos meteorológicos. Se reintentará automáticamente.'\n      });\n    }\n    let result = 0;\n    let won = false;\n    let resolution_explanation = '';\n    if (bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') {\n      result = currentRainAmount || 0;\n      if (bet.option === 'rain_yes') {\n        won = result > 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que llovería. La cantidad de lluvia registrada fue de ${result.toFixed(2)} mm.`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que llovería, pero no se registró lluvia (0 mm). Las condiciones estaban secas durante el período de verificación.`;\n        }\n      } else if (bet.option === 'rain_no') {\n        won = result === 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que no llovería. No se registró lluvia (0 mm) durante el período de verificación.`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que no llovería, pero se registraron ${result.toFixed(2)} mm de lluvia durante el período de verificación.`;\n        }\n      } else if (bet.option === 'rain_amount') {\n        const betValue = bet.rain_mm !== null ? bet.rain_mm : bet.value;\n        const margin = 0.5;\n        won = Math.abs((betValue || 0) - result) <= margin;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de ${betValue} mm de lluvia estaba dentro del margen de ±${margin} mm del valor real (${result.toFixed(2)} mm).`;\n        } else {\n          const difference = Math.abs((betValue || 0) - result).toFixed(2);\n          resolution_explanation = `Perdiste. Tu predicción de ${betValue} mm de lluvia difería ${difference} mm del valor real (${result.toFixed(2)} mm), superando el margen permitido de ±${margin} mm.`;\n        }\n      }\n    } else if (bet.option === 'temp_min') {\n      if (!currentTemperature) {\n        await addToPendingResolutions(bet);\n        return Object.assign({}, bet, {\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'\n        });\n      }\n      result = currentTemperature.min;\n      const betValue = bet.temp_min_c !== null ? bet.temp_min_c : bet.value;\n      const margin = 1.0;\n      won = Math.abs((betValue || 0) - result) <= margin;\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de temperatura mínima de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de temperatura mínima de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;\n      }\n    } else if (bet.option === 'temp_max') {\n      if (!currentTemperature) {\n        await addToPendingResolutions(bet);\n        return Object.assign({}, bet, {\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'\n        });\n      }\n      result = currentTemperature.max;\n      const betValue = bet.temp_max_c !== null ? bet.temp_max_c : bet.value;\n      const margin = 1.0;\n      won = Math.abs((betValue || 0) - result) <= margin;\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de temperatura máxima de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de temperatura máxima de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;\n      }\n    } else if (bet.option === 'temperature') {\n      if (!currentTemperature) {\n        await addToPendingResolutions(bet);\n        return Object.assign({}, bet, {\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'\n        });\n      }\n      result = currentTemperature.current;\n      const betValue = bet.temperature_c !== null ? bet.temperature_c : bet.value;\n      const margin = 1.0;\n      won = Math.abs((betValue || 0) - result) <= margin;\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de temperatura actual de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de temperatura actual de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;\n      }\n    } else if (bet.option === 'wind_max') {\n      if (!currentWind) {\n        await addToPendingResolutions(bet);\n        return Object.assign({}, bet, {\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de viento. Se reintentará automáticamente.'\n        });\n      }\n      result = currentWind.max;\n      const betValue = bet.wind_kmh_max !== null ? bet.wind_kmh_max : bet.value;\n      const margin = 3.0;\n      won = Math.abs((betValue || 0) - result) <= margin;\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de velocidad máxima del viento de ${betValue} km/h estaba dentro del margen de ±${margin} km/h del valor real (${result.toFixed(1)} km/h).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de velocidad máxima del viento de ${betValue} km/h difería ${difference} km/h del valor real (${result.toFixed(1)} km/h), superando el margen permitido de ±${margin} km/h.`;\n      }\n    }\n    const resolvedBet = Object.assign({}, bet, {\n      result,\n      won,\n      verified: true,\n      status: won ? 'ganada' : 'perdida',\n      resolution_explanation\n    });\n    await removeFromPendingResolutions(bet.id);\n    return resolvedBet;\n  } catch (error) {\n    console.error('Error al resolver la apuesta:', error, bet.id);\n    await logResolutionError(bet, error.message || 'Error desconocido');\n    await addToPendingResolutions(bet);\n    return Object.assign({}, bet, {\n      resolution_explanation: 'Error al resolver la apuesta. Se reintentará automáticamente.'\n    });\n  }\n};\nexport const resolveAllPendingBets = async () => {\n  try {\n    const betsJson = await AsyncStorage.getItem('local_bets');\n    if (!betsJson) return;\n    const bets = JSON.parse(betsJson);\n    const now = new Date();\n    const pendingBets = bets.filter(bet => bet.status === 'pending' && !bet.verified && new Date(bet.verificationTime || '').getTime() <= now.getTime());\n    if (pendingBets.length === 0) return;\n    const updatedBets = [...bets];\n    let hasChanges = false;\n    for (const bet of pendingBets) {\n      const resolvedBet = await resolveBet(bet);\n      if (resolvedBet.verified !== bet.verified || resolvedBet.status !== bet.status || resolvedBet.result !== bet.result || resolvedBet.won !== bet.won) {\n        const index = updatedBets.findIndex(b => b.id === bet.id);\n        if (index !== -1) {\n          updatedBets[index] = resolvedBet;\n          hasChanges = true;\n        }\n      }\n    }\n    if (hasChanges) {\n      await AsyncStorage.setItem('local_bets', JSON.stringify(updatedBets));\n    }\n    await retryPendingResolutions();\n  } catch (error) {\n    console.error('Error al resolver apuestas pendientes:', error);\n  }\n};\nconst addToPendingResolutions = async bet => {\n  try {\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    const pendingBets = pendingJson ? JSON.parse(pendingJson) : [];\n    if (!pendingBets.includes(bet.id)) {\n      pendingBets.push(bet.id);\n      await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY, JSON.stringify(pendingBets));\n    }\n  } catch (error) {\n    console.error('Error al agregar a resoluciones pendientes:', error);\n  }\n};\nconst removeFromPendingResolutions = async betId => {\n  try {\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    if (!pendingJson) return;\n    const pendingBets = JSON.parse(pendingJson);\n    const updatedPending = pendingBets.filter(id => id !== betId);\n    await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY, JSON.stringify(updatedPending));\n  } catch (error) {\n    console.error('Error al eliminar de resoluciones pendientes:', error);\n  }\n};\nconst logResolutionError = async (bet, errorMessage) => {\n  try {\n    const failedJson = await AsyncStorage.getItem(FAILED_RESOLUTIONS_KEY);\n    const failedResolutions = failedJson ? JSON.parse(failedJson) : {};\n    failedResolutions[bet.id] = {\n      count: (failedResolutions[bet.id]?.count || 0) + 1,\n      lastError: errorMessage,\n      timestamp: new Date().toISOString()\n    };\n    await AsyncStorage.setItem(FAILED_RESOLUTIONS_KEY, JSON.stringify(failedResolutions));\n  } catch (error) {\n    console.error('Error al registrar error de resolución:', error);\n  }\n};\nconst recordResolutionAttempt = async bet => {\n  try {\n    const attemptsJson = await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);\n    const attempts = attemptsJson ? JSON.parse(attemptsJson) : {};\n    attempts[bet.id] = (attempts[bet.id] || 0) + 1;\n    await AsyncStorage.setItem(RESOLUTION_ATTEMPTS_KEY, JSON.stringify(attempts));\n  } catch (error) {\n    console.error('Error al registrar intento de resolución:', error);\n  }\n};\nconst retryPendingResolutions = async () => {\n  try {\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    if (!pendingJson) return;\n    const pendingBetIds = JSON.parse(pendingJson);\n    if (pendingBetIds.length === 0) return;\n    const betsJson = await AsyncStorage.getItem('local_bets');\n    if (!betsJson) return;\n    const bets = JSON.parse(betsJson);\n    const updatedBets = [...bets];\n    let hasChanges = false;\n    const attemptsJson = await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);\n    const attempts = attemptsJson ? JSON.parse(attemptsJson) : {};\n    for (const betId of pendingBetIds) {\n      if ((attempts[betId] || 0) >= MAX_RETRY_ATTEMPTS) {\n        console.warn(`Máximo de intentos alcanzado para la apuesta ${betId}. Marcando como fallida.`);\n        const index = updatedBets.findIndex(b => b.id === betId);\n        if (index !== -1) {\n          updatedBets[index] = Object.assign({}, updatedBets[index], {\n            status: 'error',\n            verified: true,\n            resolution_explanation: 'No se pudo resolver la apuesta después de múltiples intentos. Por favor, contacta con soporte.'\n          });\n          hasChanges = true;\n        }\n        await removeFromPendingResolutions(betId);\n        continue;\n      }\n      const bet = bets.find(b => b.id === betId);\n      if (!bet) {\n        await removeFromPendingResolutions(betId);\n        continue;\n      }\n      const resolvedBet = await resolveBet(bet);\n      if (resolvedBet.verified && (resolvedBet.status === 'ganada' || resolvedBet.status === 'perdida')) {\n        const index = updatedBets.findIndex(b => b.id === betId);\n        if (index !== -1) {\n          updatedBets[index] = resolvedBet;\n          hasChanges = true;\n        }\n        await removeFromPendingResolutions(betId);\n      }\n    }\n    if (hasChanges) {\n      await AsyncStorage.setItem('local_bets', JSON.stringify(updatedBets));\n    }\n  } catch (error) {\n    console.error('Error al reintentar resoluciones pendientes:', error);\n  }\n};\nexport const cleanupResolutionData = async () => {\n  try {\n    const attemptsJson = await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);\n    if (attemptsJson) {\n      const attempts = JSON.parse(attemptsJson);\n      const betsJson = await AsyncStorage.getItem('local_bets');\n      const bets = betsJson ? JSON.parse(betsJson) : [];\n      const currentBetIds = new Set(bets.map(bet => bet.id));\n      const updatedAttempts = {};\n      for (const [betId, count] of Object.entries(attempts)) {\n        if (currentBetIds.has(betId)) {\n          updatedAttempts[betId] = count;\n        }\n      }\n      await AsyncStorage.setItem(RESOLUTION_ATTEMPTS_KEY, JSON.stringify(updatedAttempts));\n    }\n    const failedJson = await AsyncStorage.getItem(FAILED_RESOLUTIONS_KEY);\n    if (failedJson) {\n      const failedResolutions = JSON.parse(failedJson);\n      const betsJson = await AsyncStorage.getItem('local_bets');\n      const bets = betsJson ? JSON.parse(betsJson) : [];\n      const currentBetIds = new Set(bets.map(bet => bet.id));\n      const updatedFailedResolutions = {};\n      for (const [betId, data] of Object.entries(failedResolutions)) {\n        if (currentBetIds.has(betId)) {\n          updatedFailedResolutions[betId] = data;\n        }\n      }\n      await AsyncStorage.setItem(FAILED_RESOLUTIONS_KEY, JSON.stringify(updatedFailedResolutions));\n    }\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    if (pendingJson) {\n      const pendingBetIds = JSON.parse(pendingJson);\n      const betsJson = await AsyncStorage.getItem('local_bets');\n      const bets = betsJson ? JSON.parse(betsJson) : [];\n      const currentBetIds = new Set(bets.map(bet => bet.id));\n      const updatedPendingBetIds = pendingBetIds.filter(id => currentBetIds.has(id));\n      await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY, JSON.stringify(updatedPendingBetIds));\n    }\n  } catch (error) {\n    console.error('Error al limpiar datos de resolución:', error);\n  }\n};\nexport const resolveBets = async () => {\n  try {\n    const pendingBets = await getPendingBets();\n    const resolvedBets = [];\n    let totalCoinsWon = 0;\n    for (const bet of pendingBets) {\n      const resolvedBet = await resolveBet(bet);\n      if (resolvedBet.verified && resolvedBet.status === 'ganada') {\n        const winnings = resolvedBet.coins * (resolvedBet.leverage || 1);\n        totalCoinsWon += winnings;\n      }\n      if (resolvedBet.verified) {\n        resolvedBets.push(resolvedBet);\n      }\n    }\n    return {\n      resolvedBets,\n      totalCoinsWon\n    };\n  } catch (error) {\n    console.error('Error al resolver apuestas:', error);\n    return {\n      resolvedBets: [],\n      totalCoinsWon: 0\n    };\n  }\n};\nconst getPendingBets = async () => {\n  try {\n    const betsString = await AsyncStorage.getItem('bets');\n    if (!betsString) return [];\n    const bets = JSON.parse(betsString);\n    return bets.filter(bet => !bet.verified && bet.status === 'pending');\n  } catch (error) {\n    console.error('Error al obtener apuestas pendientes:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["fetchCurrentRainData","fetchCurrentTemperatureData","fetchCurrentWindData","AsyncStorage","PENDING_RESOLUTIONS_KEY","FAILED_RESOLUTIONS_KEY","RESOLUTION_ATTEMPTS_KEY","MAX_RETRY_ATTEMPTS","resolveBet","bet","verified","status","now","Date","verificationTime","isNaN","getTime","console","error","id","logResolutionError","Object","assign","resolution_explanation","recordResolutionAttempt","currentRainAmount","currentTemperature","currentWind","Promise","all","catch","option","addToPendingResolutions","result","won","toFixed","betValue","rain_mm","value","margin","Math","abs","difference","min","temp_min_c","max","temp_max_c","current","temperature_c","wind_kmh_max","resolvedBet","removeFromPendingResolutions","message","resolveAllPendingBets","betsJson","getItem","bets","JSON","parse","pendingBets","filter","length","updatedBets","hasChanges","index","findIndex","b","setItem","stringify","retryPendingResolutions","pendingJson","includes","push","betId","updatedPending","errorMessage","failedJson","failedResolutions","count","lastError","timestamp","toISOString","attemptsJson","attempts","pendingBetIds","warn","find","cleanupResolutionData","currentBetIds","Set","map","updatedAttempts","entries","has","updatedFailedResolutions","data","updatedPendingBetIds","resolveBets","getPendingBets","resolvedBets","totalCoinsWon","winnings","coins","leverage","betsString"],"sources":["/Users/atemjohnatem/Downloads/meteo-malaga/src/utils/resolveBets.ts"],"sourcesContent":["import { Bet } from '../types/weather';\nimport { fetchCurrentRainData, fetchCurrentTemperatureData, fetchCurrentWindData } from '../services/weatherService';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// Claves para almacenamiento local\nconst PENDING_RESOLUTIONS_KEY = 'pendingBetResolutions';\nconst FAILED_RESOLUTIONS_KEY = 'failedBetResolutions';\nconst RESOLUTION_ATTEMPTS_KEY = 'betResolutionAttempts';\nconst MAX_RETRY_ATTEMPTS = 5;\n\n// Función para resolver una apuesta individual\nexport const resolveBet = async (bet: Bet): Promise<Bet> => {\n  try {\n    // Omitir si la apuesta ya está resuelta\n    if (bet.verified || bet.status === 'ganada' || bet.status === 'perdida') {\n      return bet;\n    }\n    \n    // Verificar si es momento de resolver la apuesta\n    const now = new Date();\n    const verificationTime = new Date(bet.verificationTime || '');\n    \n    if (isNaN(verificationTime.getTime())) {\n      console.error('Tiempo de verificación inválido para la apuesta:', bet.id);\n      await logResolutionError(bet, 'Tiempo de verificación inválido');\n      return {\n        ...bet,\n        resolution_explanation: 'No se pudo resolver: tiempo de verificación inválido. Se reintentará más tarde.'\n      };\n    }\n    \n    if (now < verificationTime) {\n      return bet; // Aún no es tiempo de resolver\n    }\n    \n    // Registrar intento de resolución\n    await recordResolutionAttempt(bet);\n    \n    // Obtener datos meteorológicos actuales\n    const [currentRainAmount, currentTemperature, currentWind] = await Promise.all([\n      fetchCurrentRainData().catch(error => {\n        console.error('Error al obtener datos de lluvia:', error);\n        return null;\n      }),\n      fetchCurrentTemperatureData().catch(error => {\n        console.error('Error al obtener datos de temperatura:', error);\n        return null;\n      }),\n      fetchCurrentWindData().catch(error => {\n        console.error('Error al obtener datos de viento:', error);\n        return null;\n      })\n    ]);\n    \n    // Verificar si se obtuvieron los datos necesarios\n    if (\n      (bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') && currentRainAmount === null ||\n      (bet.option === 'temp_min' || bet.option === 'temp_max' || bet.option === 'temperature') && currentTemperature === null ||\n      (bet.option === 'wind_max') && currentWind === null\n    ) {\n      console.error('Datos meteorológicos no disponibles para resolver la apuesta:', bet.id);\n      await addToPendingResolutions(bet);\n      return {\n        ...bet,\n        resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos meteorológicos. Se reintentará automáticamente.'\n      };\n    }\n    \n    // Determinar el resultado real según el tipo de apuesta\n    let result = 0;\n    let won = false;\n    let resolution_explanation = '';\n    \n    if (bet.option === 'rain_yes' || bet.option === 'rain_no' || bet.option === 'rain_amount') {\n      result = currentRainAmount || 0;\n      \n      if (bet.option === 'rain_yes') {\n        won = result > 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que llovería. La cantidad de lluvia registrada fue de ${result.toFixed(2)} mm.`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que llovería, pero no se registró lluvia (0 mm). Las condiciones estaban secas durante el período de verificación.`;\n        }\n      } else if (bet.option === 'rain_no') {\n        won = result === 0;\n        if (won) {\n          resolution_explanation = `¡Ganaste! Predijiste correctamente que no llovería. No se registró lluvia (0 mm) durante el período de verificación.`;\n        } else {\n          resolution_explanation = `Perdiste. Predijiste que no llovería, pero se registraron ${result.toFixed(2)} mm de lluvia durante el período de verificación.`;\n        }\n      } else if (bet.option === 'rain_amount') {\n        const betValue = bet.rain_mm !== null ? bet.rain_mm : bet.value;\n        \n        // Usar un margen fijo para todos los modos\n        const margin = 0.5;\n        won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±0.5mm\n        if (won) {\n          resolution_explanation = `¡Ganaste! Tu predicción de ${betValue} mm de lluvia estaba dentro del margen de ±${margin} mm del valor real (${result.toFixed(2)} mm).`;\n        } else {\n          const difference = Math.abs((betValue || 0) - result).toFixed(2);\n          resolution_explanation = `Perdiste. Tu predicción de ${betValue} mm de lluvia difería ${difference} mm del valor real (${result.toFixed(2)} mm), superando el margen permitido de ±${margin} mm.`;\n        }\n      }\n    } else if (bet.option === 'temp_min') {\n      if (!currentTemperature) {\n        await addToPendingResolutions(bet);\n                return {\n          ...bet,\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'\n        };\n      }\n      \n      result = currentTemperature.min;\n      const betValue = bet.temp_min_c !== null ? bet.temp_min_c : bet.value;\n      \n      // Usar un margen fijo para todos los modos\n      const margin = 1.0;\n      won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±1.0°C\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de temperatura mínima de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de temperatura mínima de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;\n      }\n    } else if (bet.option === 'temp_max') {\n      if (!currentTemperature) {\n        await addToPendingResolutions(bet);\n        return {\n          ...bet,\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'\n        };\n      }\n      \n      result = currentTemperature.max;\n      const betValue = bet.temp_max_c !== null ? bet.temp_max_c : bet.value;\n      \n      // Usar un margen fijo para todos los modos\n      const margin = 1.0;\n      won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±1.0°C\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de temperatura máxima de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de temperatura máxima de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;\n      }\n    } else if (bet.option === 'temperature') {\n      if (!currentTemperature) {\n        await addToPendingResolutions(bet);\n        return {\n          ...bet,\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de temperatura. Se reintentará automáticamente.'\n        };\n      }\n      \n      result = currentTemperature.current;\n      const betValue = bet.temperature_c !== null ? bet.temperature_c : bet.value;\n      \n      // Usar un margen fijo para todos los modos\n      const margin = 1.0;\n      won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±1.0°C\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de temperatura actual de ${betValue}°C estaba dentro del margen de ±${margin}°C del valor real (${result.toFixed(1)}°C).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de temperatura actual de ${betValue}°C difería ${difference}°C del valor real (${result.toFixed(1)}°C), superando el margen permitido de ±${margin}°C.`;\n      }\n    } else if (bet.option === 'wind_max') {\n      if (!currentWind) {\n        await addToPendingResolutions(bet);\n        return {\n          ...bet,\n          resolution_explanation: 'Resolución pendiente: no se pudieron obtener datos de viento. Se reintentará automáticamente.'\n        };\n      }\n      \n      result = currentWind.max;\n      const betValue = bet.wind_kmh_max !== null ? bet.wind_kmh_max : bet.value;\n      \n      // Usar un margen fijo para todos los modos\n      const margin = 3.0;\n      won = Math.abs((betValue || 0) - result) <= margin; // Ganar si está dentro de ±3.0 km/h\n      if (won) {\n        resolution_explanation = `¡Ganaste! Tu predicción de velocidad máxima del viento de ${betValue} km/h estaba dentro del margen de ±${margin} km/h del valor real (${result.toFixed(1)} km/h).`;\n      } else {\n        const difference = Math.abs((betValue || 0) - result).toFixed(1);\n        resolution_explanation = `Perdiste. Tu predicción de velocidad máxima del viento de ${betValue} km/h difería ${difference} km/h del valor real (${result.toFixed(1)} km/h), superando el margen permitido de ±${margin} km/h.`;\n      }\n    }\n    \n    // Actualizar la apuesta con el resultado\n    const resolvedBet: Bet = {\n      ...bet,\n      result,\n      won,\n      verified: true,\n      status: won ? 'ganada' : 'perdida',\n      resolution_explanation\n    };\n    \n    // Eliminar de las resoluciones pendientes si estaba allí\n    await removeFromPendingResolutions(bet.id);\n    \n    return resolvedBet;\n  } catch (error) {\n    console.error('Error al resolver la apuesta:', error, bet.id);\n    await logResolutionError(bet, error.message || 'Error desconocido');\n    await addToPendingResolutions(bet);\n    \n    return {\n      ...bet,\n      resolution_explanation: 'Error al resolver la apuesta. Se reintentará automáticamente.'\n    };\n  }\n};\n\n// Función para resolver todas las apuestas pendientes\nexport const resolveAllPendingBets = async (): Promise<void> => {\n  try {\n    // Obtener todas las apuestas del almacenamiento local\n    const betsJson = await AsyncStorage.getItem('local_bets');\n    if (!betsJson) return;\n    \n    const bets: Bet[] = JSON.parse(betsJson);\n    const now = new Date();\n    \n    // Filtrar apuestas pendientes que deberían resolverse\n    const pendingBets = bets.filter(bet => \n      bet.status === 'pending' && \n      !bet.verified && \n      new Date(bet.verificationTime || '').getTime() <= now.getTime()\n    );\n    \n    if (pendingBets.length === 0) return;\n    \n    // Resolver cada apuesta pendiente\n    const updatedBets = [...bets];\n    let hasChanges = false;\n    \n    for (const bet of pendingBets) {\n      const resolvedBet = await resolveBet(bet);\n      \n      // Si la apuesta cambió, actualizar en el array\n      if (\n        resolvedBet.verified !== bet.verified || \n        resolvedBet.status !== bet.status || \n        resolvedBet.result !== bet.result || \n        resolvedBet.won !== bet.won\n      ) {\n        const index = updatedBets.findIndex(b => b.id === bet.id);\n        if (index !== -1) {\n          updatedBets[index] = resolvedBet;\n          hasChanges = true;\n        }\n      }\n    }\n    \n    // Guardar las apuestas actualizadas si hubo cambios\n    if (hasChanges) {\n      await AsyncStorage.setItem('local_bets', JSON.stringify(updatedBets));\n    }\n    \n    // Intentar resolver apuestas pendientes anteriores\n    await retryPendingResolutions();\n  } catch (error) {\n    console.error('Error al resolver apuestas pendientes:', error);\n  }\n};\n\n// Función para agregar una apuesta a las resoluciones pendientes\nconst addToPendingResolutions = async (bet: Bet): Promise<void> => {\n  try {\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    const pendingBets: string[] = pendingJson ? JSON.parse(pendingJson) : [];\n    \n    // Agregar el ID de la apuesta si no está ya\n    if (!pendingBets.includes(bet.id)) {\n      pendingBets.push(bet.id);\n      await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY, JSON.stringify(pendingBets));\n    }\n  } catch (error) {\n    console.error('Error al agregar a resoluciones pendientes:', error);\n  }\n};\n\n// Función para eliminar una apuesta de las resoluciones pendientes\nconst removeFromPendingResolutions = async (betId: string): Promise<void> => {\n  try {\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    if (!pendingJson) return;\n    \n    const pendingBets: string[] = JSON.parse(pendingJson);\n    const updatedPending = pendingBets.filter(id => id !== betId);\n    \n    await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY, JSON.stringify(updatedPending));\n  } catch (error) {\n    console.error('Error al eliminar de resoluciones pendientes:', error);\n  }\n};\n\n// Función para registrar un error de resolución\nconst logResolutionError = async (bet: Bet, errorMessage: string): Promise<void> => {\n  try {\n    const failedJson = await AsyncStorage.getItem(FAILED_RESOLUTIONS_KEY);\n    const failedResolutions: Record<string, { count: number, lastError: string, timestamp: string }> = \n      failedJson ? JSON.parse(failedJson) : {};\n    \n    // Actualizar o agregar el registro de error\n    failedResolutions[bet.id] = {\n      count: (failedResolutions[bet.id]?.count || 0) + 1,\n      lastError: errorMessage,\n      timestamp: new Date().toISOString()\n    };\n    \n    await AsyncStorage.setItem(FAILED_RESOLUTIONS_KEY, JSON.stringify(failedResolutions));\n  } catch (error) {\n    console.error('Error al registrar error de resolución:', error);\n  }\n};\n\n// Función para registrar un intento de resolución\nconst recordResolutionAttempt = async (bet: Bet): Promise<void> => {\n  try {\n    const attemptsJson = await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);\n    const attempts: Record<string, number> = attemptsJson ? JSON.parse(attemptsJson) : {};\n    \n    // Incrementar el contador de intentos\n    attempts[bet.id] = (attempts[bet.id] || 0) + 1;\n    \n    await AsyncStorage.setItem(RESOLUTION_ATTEMPTS_KEY, JSON.stringify(attempts));\n  } catch (error) {\n    console.error('Error al registrar intento de resolución:', error);\n  }\n};\n\n// Función para reintentar resoluciones pendientes\nconst retryPendingResolutions = async (): Promise<void> => {\n  try {\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    if (!pendingJson) return;\n    \n    const pendingBetIds: string[] = JSON.parse(pendingJson);\n    if (pendingBetIds.length === 0) return;\n    \n    // Obtener todas las apuestas\n    const betsJson = await AsyncStorage.getItem('local_bets');\n    if (!betsJson) return;\n    \n    const bets: Bet[] = JSON.parse(betsJson);\n    const updatedBets = [...bets];\n    let hasChanges = false;\n    \n    // Obtener intentos de resolución\n    const attemptsJson = await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);\n    const attempts: Record<string, number> = attemptsJson ? JSON.parse(attemptsJson) : {};\n    \n    // Procesar cada apuesta pendiente\n    for (const betId of pendingBetIds) {\n      // Verificar si se ha excedido el número máximo de intentos\n      if ((attempts[betId] || 0) >= MAX_RETRY_ATTEMPTS) {\n        console.warn(`Máximo de intentos alcanzado para la apuesta ${betId}. Marcando como fallida.`);\n        \n        // Marcar la apuesta como fallida después de demasiados intentos\n        const index = updatedBets.findIndex(b => b.id === betId);\n        if (index !== -1) {\n          updatedBets[index] = {\n            ...updatedBets[index],\n            status: 'error',\n            verified: true,\n            resolution_explanation: 'No se pudo resolver la apuesta después de múltiples intentos. Por favor, contacta con soporte.'\n          };\n          hasChanges = true;\n        }\n        \n        // Eliminar de las resoluciones pendientes\n        await removeFromPendingResolutions(betId);\n        continue;\n      }\n      \n      // Encontrar la apuesta en el array\n      const bet = bets.find(b => b.id === betId);\n      if (!bet) {\n        await removeFromPendingResolutions(betId);\n        continue;\n      }\n      \n      // Intentar resolver la apuesta\n      const resolvedBet = await resolveBet(bet);\n      \n      // Si la apuesta se resolvió correctamente, actualizar en el array\n      if (resolvedBet.verified && (resolvedBet.status === 'ganada' || resolvedBet.status === 'perdida')) {\n        const index = updatedBets.findIndex(b => b.id === betId);\n        if (index !== -1) {\n          updatedBets[index] = resolvedBet;\n          hasChanges = true;\n        }\n        \n        // Eliminar de las resoluciones pendientes\n        await removeFromPendingResolutions(betId);\n      }\n    }\n    \n    // Guardar las apuestas actualizadas si hubo cambios\n    if (hasChanges) {\n      await AsyncStorage.setItem('local_bets', JSON.stringify(updatedBets));\n    }\n  } catch (error) {\n    console.error('Error al reintentar resoluciones pendientes:', error);\n  }\n};\n\n// Función para limpiar datos antiguos de resolución\nexport const cleanupResolutionData = async (): Promise<void> => {\n  try {\n    // Limpiar intentos de resolución antiguos\n    const attemptsJson = await AsyncStorage.getItem(RESOLUTION_ATTEMPTS_KEY);\n    if (attemptsJson) {\n      const attempts: Record<string, number> = JSON.parse(attemptsJson);\n      \n      // Obtener apuestas actuales\n      const betsJson = await AsyncStorage.getItem('local_bets');\n      const bets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n      const currentBetIds = new Set(bets.map(bet => bet.id));\n      \n      // Filtrar intentos para mantener solo los de apuestas actuales\n      const updatedAttempts: Record<string, number> = {};\n      for (const [betId, count] of Object.entries(attempts)) {\n        if (currentBetIds.has(betId)) {\n          updatedAttempts[betId] = count;\n        }\n      }\n      \n      await AsyncStorage.setItem(RESOLUTION_ATTEMPTS_KEY, JSON.stringify(updatedAttempts));\n    }\n    \n    // Limpiar errores de resolución antiguos\n    const failedJson = await AsyncStorage.getItem(FAILED_RESOLUTIONS_KEY);\n    if (failedJson) {\n      const failedResolutions: Record<string, { count: number, lastError: string, timestamp: string }> = \n        JSON.parse(failedJson);\n      \n      // Obtener apuestas actuales\n      const betsJson = await AsyncStorage.getItem('local_bets');\n      const bets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n      const currentBetIds = new Set(bets.map(bet => bet.id));\n      \n      // Filtrar errores para mantener solo los de apuestas actuales\n      const updatedFailedResolutions: Record<string, { count: number, lastError: string, timestamp: string }> = {};\n      for (const [betId, data] of Object.entries(failedResolutions)) {\n        if (currentBetIds.has(betId)) {\n          updatedFailedResolutions[betId] = data;\n        }\n      }\n      \n      await AsyncStorage.setItem(FAILED_RESOLUTIONS_KEY, JSON.stringify(updatedFailedResolutions));\n    }\n    \n    // Verificar y limpiar resoluciones pendientes\n    const pendingJson = await AsyncStorage.getItem(PENDING_RESOLUTIONS_KEY);\n    if (pendingJson) {\n      const pendingBetIds: string[] = JSON.parse(pendingJson);\n      \n      // Obtener apuestas actuales\n      const betsJson = await AsyncStorage.getItem('local_bets');\n      const bets: Bet[] = betsJson ? JSON.parse(betsJson) : [];\n      const currentBetIds = new Set(bets.map(bet => bet.id));\n      \n      // Filtrar para mantener solo IDs de apuestas actuales\n      const updatedPendingBetIds = pendingBetIds.filter(id => currentBetIds.has(id));\n      \n      await AsyncStorage.setItem(PENDING_RESOLUTIONS_KEY, JSON.stringify(updatedPendingBetIds));\n    }\n  } catch (error) {\n    console.error('Error al limpiar datos de resolución:', error);\n  }\n};\n\n// Función para resolver todas las apuestas pendientes y devolver resultados\nexport const resolveBets = async (): Promise<{ resolvedBets: Bet[], totalCoinsWon: number }> => {\n  try {\n    const pendingBets = await getPendingBets();\n    const resolvedBets: Bet[] = [];\n    let totalCoinsWon = 0;\n    \n    for (const bet of pendingBets) {\n      const resolvedBet = await resolveBet(bet);\n      \n      if (resolvedBet.verified && resolvedBet.status === 'ganada') {\n        const winnings = resolvedBet.coins * (resolvedBet.leverage || 1);\n        totalCoinsWon += winnings;\n      }\n      \n      if (resolvedBet.verified) {\n        resolvedBets.push(resolvedBet);\n      }\n    }\n    \n    return { resolvedBets, totalCoinsWon };\n  } catch (error) {\n    console.error('Error al resolver apuestas:', error);\n    return { resolvedBets: [], totalCoinsWon: 0 };\n  }\n};\n\n// Función auxiliar para obtener apuestas pendientes\nconst getPendingBets = async (): Promise<Bet[]> => {\n  try {\n    const betsString = await AsyncStorage.getItem('bets');\n    if (!betsString) return [];\n    \n    const bets: Bet[] = JSON.parse(betsString);\n    return bets.filter(bet => !bet.verified && bet.status === 'pending');\n  } catch (error) {\n    console.error('Error al obtener apuestas pendientes:', error);\n    return [];\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}