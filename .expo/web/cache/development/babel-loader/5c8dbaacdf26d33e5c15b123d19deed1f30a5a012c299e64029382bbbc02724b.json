{"ast":null,"code":"import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { addPendingReward } from \"./plantService\";\nconst BETS_STORAGE_KEY = 'bets';\nconst RESOLVED_BETS_STORAGE_KEY = 'recently_resolved_bets';\nconst VERIFICATION_INTERVAL = 60000;\nexport const getLocalBets = async () => {\n  try {\n    const betsString = await AsyncStorage.getItem(BETS_STORAGE_KEY);\n    if (!betsString) return [];\n    return JSON.parse(betsString);\n  } catch (error) {\n    console.error('Error getting local bets:', error);\n    return [];\n  }\n};\nexport const saveBet = async bet => {\n  try {\n    const bets = await getLocalBets();\n    const newBet = Object.assign({}, bet, {\n      id: Date.now(),\n      timestamp: new Date().toISOString(),\n      status: 'pending'\n    });\n    const updatedBets = [newBet, ...bets];\n    await AsyncStorage.setItem(BETS_STORAGE_KEY, JSON.stringify(updatedBets));\n    return newBet;\n  } catch (error) {\n    console.error('Error saving bet:', error);\n    throw new Error('Error saving bet');\n  }\n};\nexport const resolveBet = async (betId, actualValue) => {\n  try {\n    const betsString = await AsyncStorage.getItem(BETS_STORAGE_KEY);\n    if (!betsString) return;\n    const bets = JSON.parse(betsString);\n    const betIndex = bets.findIndex(bet => bet.id === betId);\n    if (betIndex === -1) return;\n    const bet = bets[betIndex];\n    let success = false;\n    let betType = 'rain';\n    if (bet.type === 'rain') {\n      success = Math.abs(bet.value - actualValue) <= 2;\n      betType = 'rain';\n    } else if (bet.type === 'temperature_min') {\n      success = Math.abs(bet.value - actualValue) <= 1;\n      betType = 'temp_min';\n    } else if (bet.type === 'temperature_max') {\n      success = Math.abs(bet.value - actualValue) <= 1;\n      betType = 'temp_max';\n    }\n    bet.status = success ? 'won' : 'lost';\n    bet.actualValue = actualValue;\n    bet.resolvedAt = new Date().toISOString();\n    bets[betIndex] = bet;\n    await AsyncStorage.setItem(BETS_STORAGE_KEY, JSON.stringify(bets));\n    if (success) {\n      await addPendingReward(betType, true);\n    }\n    return {\n      success,\n      bet\n    };\n  } catch (error) {\n    console.error('Error resolving bet:', error);\n    return {\n      success: false\n    };\n  }\n};\nexport const startBackgroundVerification = callback => {\n  let intervalId;\n  const verifyBets = async () => {\n    try {\n      const bets = await getLocalBets();\n      const pendingBets = bets.filter(bet => bet.status === 'pending');\n      if (pendingBets.length === 0) return;\n      const now = new Date();\n      const resolvedBets = [];\n      let totalCoinsWon = 0;\n      for (const bet of pendingBets) {\n        const betDate = new Date(bet.date);\n        if (betDate <= now) {\n          const actualValue = Math.random() * 30;\n          const {\n            success,\n            bet: resolvedBet\n          } = (await resolveBet(bet.id, actualValue)) || {};\n          if (resolvedBet) {\n            resolvedBets.push(resolvedBet);\n            if (success) {\n              const winnings = bet.coins * bet.leverage;\n              totalCoinsWon += winnings;\n            }\n          }\n        }\n      }\n      if (resolvedBets.length > 0) {\n        await storeRecentlyResolvedBets(resolvedBets);\n        callback(resolvedBets, totalCoinsWon);\n      }\n    } catch (error) {\n      console.error('Error verifying bets:', error);\n    }\n  };\n  intervalId = setInterval(verifyBets, VERIFICATION_INTERVAL);\n  return () => {\n    clearInterval(intervalId);\n  };\n};\nconst storeRecentlyResolvedBets = async resolvedBets => {\n  try {\n    const recentlyResolvedBetsString = await AsyncStorage.getItem(RESOLVED_BETS_STORAGE_KEY);\n    let recentlyResolvedBets = [];\n    if (recentlyResolvedBetsString) {\n      recentlyResolvedBets = JSON.parse(recentlyResolvedBetsString);\n    }\n    recentlyResolvedBets = [...recentlyResolvedBets, ...resolvedBets];\n    await AsyncStorage.setItem(RESOLVED_BETS_STORAGE_KEY, JSON.stringify(recentlyResolvedBets));\n  } catch (error) {\n    console.error('Error storing recently resolved bets:', error);\n  }\n};\nexport const getAndClearRecentlyResolvedBets = async () => {\n  try {\n    const recentlyResolvedBetsString = await AsyncStorage.getItem(RESOLVED_BETS_STORAGE_KEY);\n    if (!recentlyResolvedBetsString) {\n      return [];\n    }\n    const recentlyResolvedBets = JSON.parse(recentlyResolvedBetsString);\n    await AsyncStorage.setItem(RESOLVED_BETS_STORAGE_KEY, JSON.stringify([]));\n    return recentlyResolvedBets;\n  } catch (error) {\n    console.error('Error getting and clearing recently resolved bets:', error);\n    return [];\n  }\n};\nexport const cleanupOldBets = async () => {\n  try {\n    const bets = await getLocalBets();\n    const now = new Date();\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    const filteredBets = bets.filter(bet => {\n      const betDate = new Date(bet.timestamp);\n      return betDate >= thirtyDaysAgo;\n    });\n    if (filteredBets.length !== bets.length) {\n      await AsyncStorage.setItem(BETS_STORAGE_KEY, JSON.stringify(filteredBets));\n    }\n  } catch (error) {\n    console.error('Error cleaning up old bets:', error);\n  }\n};\nexport const getTemperatureOdds = (temperature, isMin) => {\n  const baseOdds = 1.5;\n  const extremityFactor = isMin ? Math.max(0, (20 - temperature) / 10) : Math.max(0, (temperature - 20) / 10);\n  return Math.min(3.0, Math.max(1.2, baseOdds + extremityFactor));\n};\nexport const getRemainingTemperatureBets = async () => {\n  try {\n    const bets = await getLocalBets();\n    const today = new Date().toISOString().split('T')[0];\n    const tempBetsToday = bets.filter(bet => {\n      const betDate = new Date(bet.timestamp).toISOString().split('T')[0];\n      return betDate === today && (bet.option === 'temp_min' || bet.option === 'temp_max');\n    });\n    return Math.max(0, 2 - tempBetsToday.length);\n  } catch (error) {\n    console.error('Error getting remaining temperature bets:', error);\n    return 0;\n  }\n};\nexport const showBetResolutionNotification = (resolvedBets, coinsWon) => {\n  console.log('Bets resolved:', resolvedBets.length);\n  console.log('Coins won:', coinsWon);\n};","map":{"version":3,"names":["AsyncStorage","addPendingReward","BETS_STORAGE_KEY","RESOLVED_BETS_STORAGE_KEY","VERIFICATION_INTERVAL","getLocalBets","betsString","getItem","JSON","parse","error","console","saveBet","bet","bets","newBet","Object","assign","id","Date","now","timestamp","toISOString","status","updatedBets","setItem","stringify","Error","resolveBet","betId","actualValue","betIndex","findIndex","success","betType","type","Math","abs","value","resolvedAt","startBackgroundVerification","callback","intervalId","verifyBets","pendingBets","filter","length","resolvedBets","totalCoinsWon","betDate","date","random","resolvedBet","push","winnings","coins","leverage","storeRecentlyResolvedBets","setInterval","clearInterval","recentlyResolvedBetsString","recentlyResolvedBets","getAndClearRecentlyResolvedBets","cleanupOldBets","thirtyDaysAgo","getTime","filteredBets","getTemperatureOdds","temperature","isMin","baseOdds","extremityFactor","max","min","getRemainingTemperatureBets","today","split","tempBetsToday","option","showBetResolutionNotification","coinsWon","log"],"sources":["/Users/atemjohnatem/Downloads/meteo-malaga/src/services/localBetService.ts"],"sourcesContent":["import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { Bet } from '../types/weather';\nimport { addPendingReward } from './plantService';\n\n// Constants\nconst BETS_STORAGE_KEY = 'bets';\nconst RESOLVED_BETS_STORAGE_KEY = 'recently_resolved_bets';\nconst VERIFICATION_INTERVAL = 60000; // 1 minute\n\n// Get all local bets\nexport const getLocalBets = async (): Promise<Bet[]> => {\n  try {\n    const betsString = await AsyncStorage.getItem(BETS_STORAGE_KEY);\n    if (!betsString) return [];\n    \n    return JSON.parse(betsString);\n  } catch (error) {\n    console.error('Error getting local bets:', error);\n    return [];\n  }\n};\n\n// Save a bet locally\nexport const saveBet = async (bet: Bet): Promise<Bet> => {\n  try {\n    const bets = await getLocalBets();\n    \n    // Add the new bet\n    const newBet = {\n      ...bet,\n      id: Date.now(), // Use timestamp as ID\n      timestamp: new Date().toISOString(),\n      status: 'pending'\n    };\n    \n    const updatedBets = [newBet, ...bets];\n    await AsyncStorage.setItem(BETS_STORAGE_KEY, JSON.stringify(updatedBets));\n    \n    return newBet;\n  } catch (error) {\n    console.error('Error saving bet:', error);\n    throw new Error('Error saving bet');\n  }\n};\n\n// Resolve a bet with the actual value\nexport const resolveBet = async (betId: number, actualValue: number) => {\n  try {\n    const betsString = await AsyncStorage.getItem(BETS_STORAGE_KEY);\n    if (!betsString) return;\n    \n    const bets = JSON.parse(betsString);\n    const betIndex = bets.findIndex((bet: any) => bet.id === betId);\n    \n    if (betIndex === -1) return;\n    \n    const bet = bets[betIndex];\n    \n    // Determine if the bet was successful based on the bet type\n    let success = false;\n    let betType: 'rain' | 'temp_min' | 'temp_max' = 'rain';\n    \n    if (bet.type === 'rain') {\n      // Rain bet: success if within ±2mm\n      success = Math.abs(bet.value - actualValue) <= 2;\n      betType = 'rain';\n    } else if (bet.type === 'temperature_min') {\n      // Min temperature bet: success if within ±1°C\n      success = Math.abs(bet.value - actualValue) <= 1;\n      betType = 'temp_min';\n    } else if (bet.type === 'temperature_max') {\n      // Max temperature bet: success if within ±1°C\n      success = Math.abs(bet.value - actualValue) <= 1;\n      betType = 'temp_max';\n    }\n    \n    // Update bet status\n    bet.status = success ? 'won' : 'lost';\n    bet.actualValue = actualValue;\n    bet.resolvedAt = new Date().toISOString();\n    \n    bets[betIndex] = bet;\n    await AsyncStorage.setItem(BETS_STORAGE_KEY, JSON.stringify(bets));\n    \n    // Add reward to plant if bet was successful\n    if (success) {\n      await addPendingReward(betType, true);\n    }\n    \n    return { success, bet };\n  } catch (error) {\n    console.error('Error resolving bet:', error);\n    return { success: false };\n  }\n};\n\n// Start background verification of bets\nexport const startBackgroundVerification = (\n  callback: (resolvedBets: Bet[], coinsWon: number) => void\n) => {\n  let intervalId: NodeJS.Timeout;\n  \n  const verifyBets = async () => {\n    try {\n      const bets = await getLocalBets();\n      const pendingBets = bets.filter(bet => bet.status === 'pending');\n      \n      if (pendingBets.length === 0) return;\n      \n      const now = new Date();\n      const resolvedBets: Bet[] = [];\n      let totalCoinsWon = 0;\n      \n      for (const bet of pendingBets) {\n        const betDate = new Date(bet.date);\n        \n        // Check if bet date has passed\n        if (betDate <= now) {\n          // TODO: In a real app, we would fetch actual weather data here\n          // For now, we'll use a random value for demonstration\n          const actualValue = Math.random() * 30; // Random value between 0 and 30\n          \n          const { success, bet: resolvedBet } = await resolveBet(bet.id, actualValue) || {};\n          \n          if (resolvedBet) {\n            resolvedBets.push(resolvedBet);\n            \n            if (success) {\n              const winnings = bet.coins * bet.leverage;\n              totalCoinsWon += winnings;\n            }\n          }\n        }\n      }\n      \n      if (resolvedBets.length > 0) {\n        // Store recently resolved bets\n        await storeRecentlyResolvedBets(resolvedBets);\n        \n        // Call the callback with resolved bets and coins won\n        callback(resolvedBets, totalCoinsWon);\n      }\n    } catch (error) {\n      console.error('Error verifying bets:', error);\n    }\n  };\n  \n  // Start the interval\n  intervalId = setInterval(verifyBets, VERIFICATION_INTERVAL);\n  \n  // Return a function to stop the interval\n  return () => {\n    clearInterval(intervalId);\n  };\n};\n\n// Store recently resolved bets\nconst storeRecentlyResolvedBets = async (resolvedBets: Bet[]) => {\n  try {\n    const recentlyResolvedBetsString = await AsyncStorage.getItem(RESOLVED_BETS_STORAGE_KEY);\n    let recentlyResolvedBets: Bet[] = [];\n    \n    if (recentlyResolvedBetsString) {\n      recentlyResolvedBets = JSON.parse(recentlyResolvedBetsString);\n    }\n    \n    // Add new resolved bets\n    recentlyResolvedBets = [...recentlyResolvedBets, ...resolvedBets];\n    \n    // Store the updated list\n    await AsyncStorage.setItem(RESOLVED_BETS_STORAGE_KEY, JSON.stringify(recentlyResolvedBets));\n  } catch (error) {\n    console.error('Error storing recently resolved bets:', error);\n  }\n};\n\n// Get and clear recently resolved bets\nexport const getAndClearRecentlyResolvedBets = async (): Promise<Bet[]> => {\n  try {\n    const recentlyResolvedBetsString = await AsyncStorage.getItem(RESOLVED_BETS_STORAGE_KEY);\n    \n    if (!recentlyResolvedBetsString) {\n      return [];\n    }\n    \n    const recentlyResolvedBets: Bet[] = JSON.parse(recentlyResolvedBetsString);\n    \n    // Clear the list\n    await AsyncStorage.setItem(RESOLVED_BETS_STORAGE_KEY, JSON.stringify([]));\n    \n    return recentlyResolvedBets;\n  } catch (error) {\n    console.error('Error getting and clearing recently resolved bets:', error);\n    return [];\n  }\n};\n\n// Clean up old bets (older than 30 days)\nexport const cleanupOldBets = async (): Promise<void> => {\n  try {\n    const bets = await getLocalBets();\n    const now = new Date();\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    \n    const filteredBets = bets.filter(bet => {\n      const betDate = new Date(bet.timestamp);\n      return betDate >= thirtyDaysAgo;\n    });\n    \n    if (filteredBets.length !== bets.length) {\n      await AsyncStorage.setItem(BETS_STORAGE_KEY, JSON.stringify(filteredBets));\n    }\n  } catch (error) {\n    console.error('Error cleaning up old bets:', error);\n  }\n};\n\n// Calculate odds for temperature bets\nexport const getTemperatureOdds = (temperature: number, isMin: boolean): number => {\n  // Base odds calculation\n  const baseOdds = 1.5;\n  \n  // Adjust odds based on temperature extremity\n  // For minimum temperature, lower values have higher odds\n  // For maximum temperature, higher values have higher odds\n  const extremityFactor = isMin \n    ? Math.max(0, (20 - temperature) / 10) // Lower min temps get higher odds\n    : Math.max(0, (temperature - 20) / 10); // Higher max temps get higher odds\n  \n  // Calculate final odds (between 1.2 and 3.0)\n  return Math.min(3.0, Math.max(1.2, baseOdds + extremityFactor));\n};\n\n// Get remaining temperature bets for today\nexport const getRemainingTemperatureBets = async (): Promise<number> => {\n  try {\n    const bets = await getLocalBets();\n    const today = new Date().toISOString().split('T')[0];\n    \n    // Count temperature bets made today\n    const tempBetsToday = bets.filter(bet => {\n      const betDate = new Date(bet.timestamp).toISOString().split('T')[0];\n      return betDate === today && (bet.option === 'temp_min' || bet.option === 'temp_max');\n    });\n    \n    // Maximum 2 temperature bets per day\n    return Math.max(0, 2 - tempBetsToday.length);\n  } catch (error) {\n    console.error('Error getting remaining temperature bets:', error);\n    return 0;\n  }\n};\n\n// Show notification about resolved bets\nexport const showBetResolutionNotification = (resolvedBets: Bet[], coinsWon: number): void => {\n  // In a real app, this would show a notification\n  // For now, we'll just log to console\n  console.log('Bets resolved:', resolvedBets.length);\n  console.log('Coins won:', coinsWon);\n};\n"],"mappings":"AAAA,OAAOA,YAAY,MAAM,2CAA2C;AAEpE,SAASC,gBAAgB;AAGzB,MAAMC,gBAAgB,GAAG,MAAM;AAC/B,MAAMC,yBAAyB,GAAG,wBAAwB;AAC1D,MAAMC,qBAAqB,GAAG,KAAK;AAGnC,OAAO,MAAMC,YAAY,GAAG,MAAAA,CAAA,KAA4B;EACtD,IAAI;IACF,MAAMC,UAAU,GAAG,MAAMN,YAAY,CAACO,OAAO,CAACL,gBAAgB,CAAC;IAC/D,IAAI,CAACI,UAAU,EAAE,OAAO,EAAE;IAE1B,OAAOE,IAAI,CAACC,KAAK,CAACH,UAAU,CAAC;EAC/B,CAAC,CAAC,OAAOI,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACjD,OAAO,EAAE;EACX;AACF,CAAC;AAGD,OAAO,MAAME,OAAO,GAAG,MAAOC,GAAQ,IAAmB;EACvD,IAAI;IACF,MAAMC,IAAI,GAAG,MAAMT,YAAY,CAAC,CAAC;IAGjC,MAAMU,MAAM,GAAAC,MAAA,CAAAC,MAAA,KACPJ,GAAG;MACNK,EAAE,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;MACdC,SAAS,EAAE,IAAIF,IAAI,CAAC,CAAC,CAACG,WAAW,CAAC,CAAC;MACnCC,MAAM,EAAE;IAAS,EAClB;IAED,MAAMC,WAAW,GAAG,CAACT,MAAM,EAAE,GAAGD,IAAI,CAAC;IACrC,MAAMd,YAAY,CAACyB,OAAO,CAACvB,gBAAgB,EAAEM,IAAI,CAACkB,SAAS,CAACF,WAAW,CAAC,CAAC;IAEzE,OAAOT,MAAM;EACf,CAAC,CAAC,OAAOL,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,mBAAmB,EAAEA,KAAK,CAAC;IACzC,MAAM,IAAIiB,KAAK,CAAC,kBAAkB,CAAC;EACrC;AACF,CAAC;AAGD,OAAO,MAAMC,UAAU,GAAG,MAAAA,CAAOC,KAAa,EAAEC,WAAmB,KAAK;EACtE,IAAI;IACF,MAAMxB,UAAU,GAAG,MAAMN,YAAY,CAACO,OAAO,CAACL,gBAAgB,CAAC;IAC/D,IAAI,CAACI,UAAU,EAAE;IAEjB,MAAMQ,IAAI,GAAGN,IAAI,CAACC,KAAK,CAACH,UAAU,CAAC;IACnC,MAAMyB,QAAQ,GAAGjB,IAAI,CAACkB,SAAS,CAAEnB,GAAQ,IAAKA,GAAG,CAACK,EAAE,KAAKW,KAAK,CAAC;IAE/D,IAAIE,QAAQ,KAAK,CAAC,CAAC,EAAE;IAErB,MAAMlB,GAAG,GAAGC,IAAI,CAACiB,QAAQ,CAAC;IAG1B,IAAIE,OAAO,GAAG,KAAK;IACnB,IAAIC,OAAyC,GAAG,MAAM;IAEtD,IAAIrB,GAAG,CAACsB,IAAI,KAAK,MAAM,EAAE;MAEvBF,OAAO,GAAGG,IAAI,CAACC,GAAG,CAACxB,GAAG,CAACyB,KAAK,GAAGR,WAAW,CAAC,IAAI,CAAC;MAChDI,OAAO,GAAG,MAAM;IAClB,CAAC,MAAM,IAAIrB,GAAG,CAACsB,IAAI,KAAK,iBAAiB,EAAE;MAEzCF,OAAO,GAAGG,IAAI,CAACC,GAAG,CAACxB,GAAG,CAACyB,KAAK,GAAGR,WAAW,CAAC,IAAI,CAAC;MAChDI,OAAO,GAAG,UAAU;IACtB,CAAC,MAAM,IAAIrB,GAAG,CAACsB,IAAI,KAAK,iBAAiB,EAAE;MAEzCF,OAAO,GAAGG,IAAI,CAACC,GAAG,CAACxB,GAAG,CAACyB,KAAK,GAAGR,WAAW,CAAC,IAAI,CAAC;MAChDI,OAAO,GAAG,UAAU;IACtB;IAGArB,GAAG,CAACU,MAAM,GAAGU,OAAO,GAAG,KAAK,GAAG,MAAM;IACrCpB,GAAG,CAACiB,WAAW,GAAGA,WAAW;IAC7BjB,GAAG,CAAC0B,UAAU,GAAG,IAAIpB,IAAI,CAAC,CAAC,CAACG,WAAW,CAAC,CAAC;IAEzCR,IAAI,CAACiB,QAAQ,CAAC,GAAGlB,GAAG;IACpB,MAAMb,YAAY,CAACyB,OAAO,CAACvB,gBAAgB,EAAEM,IAAI,CAACkB,SAAS,CAACZ,IAAI,CAAC,CAAC;IAGlE,IAAImB,OAAO,EAAE;MACX,MAAMhC,gBAAgB,CAACiC,OAAO,EAAE,IAAI,CAAC;IACvC;IAEA,OAAO;MAAED,OAAO;MAAEpB;IAAI,CAAC;EACzB,CAAC,CAAC,OAAOH,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;IAC5C,OAAO;MAAEuB,OAAO,EAAE;IAAM,CAAC;EAC3B;AACF,CAAC;AAGD,OAAO,MAAMO,2BAA2B,GACtCC,QAAyD,IACtD;EACH,IAAIC,UAA0B;EAE9B,MAAMC,UAAU,GAAG,MAAAA,CAAA,KAAY;IAC7B,IAAI;MACF,MAAM7B,IAAI,GAAG,MAAMT,YAAY,CAAC,CAAC;MACjC,MAAMuC,WAAW,GAAG9B,IAAI,CAAC+B,MAAM,CAAChC,GAAG,IAAIA,GAAG,CAACU,MAAM,KAAK,SAAS,CAAC;MAEhE,IAAIqB,WAAW,CAACE,MAAM,KAAK,CAAC,EAAE;MAE9B,MAAM1B,GAAG,GAAG,IAAID,IAAI,CAAC,CAAC;MACtB,MAAM4B,YAAmB,GAAG,EAAE;MAC9B,IAAIC,aAAa,GAAG,CAAC;MAErB,KAAK,MAAMnC,GAAG,IAAI+B,WAAW,EAAE;QAC7B,MAAMK,OAAO,GAAG,IAAI9B,IAAI,CAACN,GAAG,CAACqC,IAAI,CAAC;QAGlC,IAAID,OAAO,IAAI7B,GAAG,EAAE;UAGlB,MAAMU,WAAW,GAAGM,IAAI,CAACe,MAAM,CAAC,CAAC,GAAG,EAAE;UAEtC,MAAM;YAAElB,OAAO;YAAEpB,GAAG,EAAEuC;UAAY,CAAC,GAAG,OAAMxB,UAAU,CAACf,GAAG,CAACK,EAAE,EAAEY,WAAW,CAAC,KAAI,CAAC,CAAC;UAEjF,IAAIsB,WAAW,EAAE;YACfL,YAAY,CAACM,IAAI,CAACD,WAAW,CAAC;YAE9B,IAAInB,OAAO,EAAE;cACX,MAAMqB,QAAQ,GAAGzC,GAAG,CAAC0C,KAAK,GAAG1C,GAAG,CAAC2C,QAAQ;cACzCR,aAAa,IAAIM,QAAQ;YAC3B;UACF;QACF;MACF;MAEA,IAAIP,YAAY,CAACD,MAAM,GAAG,CAAC,EAAE;QAE3B,MAAMW,yBAAyB,CAACV,YAAY,CAAC;QAG7CN,QAAQ,CAACM,YAAY,EAAEC,aAAa,CAAC;MACvC;IACF,CAAC,CAAC,OAAOtC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC/C;EACF,CAAC;EAGDgC,UAAU,GAAGgB,WAAW,CAACf,UAAU,EAAEvC,qBAAqB,CAAC;EAG3D,OAAO,MAAM;IACXuD,aAAa,CAACjB,UAAU,CAAC;EAC3B,CAAC;AACH,CAAC;AAGD,MAAMe,yBAAyB,GAAG,MAAOV,YAAmB,IAAK;EAC/D,IAAI;IACF,MAAMa,0BAA0B,GAAG,MAAM5D,YAAY,CAACO,OAAO,CAACJ,yBAAyB,CAAC;IACxF,IAAI0D,oBAA2B,GAAG,EAAE;IAEpC,IAAID,0BAA0B,EAAE;MAC9BC,oBAAoB,GAAGrD,IAAI,CAACC,KAAK,CAACmD,0BAA0B,CAAC;IAC/D;IAGAC,oBAAoB,GAAG,CAAC,GAAGA,oBAAoB,EAAE,GAAGd,YAAY,CAAC;IAGjE,MAAM/C,YAAY,CAACyB,OAAO,CAACtB,yBAAyB,EAAEK,IAAI,CAACkB,SAAS,CAACmC,oBAAoB,CAAC,CAAC;EAC7F,CAAC,CAAC,OAAOnD,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;EAC/D;AACF,CAAC;AAGD,OAAO,MAAMoD,+BAA+B,GAAG,MAAAA,CAAA,KAA4B;EACzE,IAAI;IACF,MAAMF,0BAA0B,GAAG,MAAM5D,YAAY,CAACO,OAAO,CAACJ,yBAAyB,CAAC;IAExF,IAAI,CAACyD,0BAA0B,EAAE;MAC/B,OAAO,EAAE;IACX;IAEA,MAAMC,oBAA2B,GAAGrD,IAAI,CAACC,KAAK,CAACmD,0BAA0B,CAAC;IAG1E,MAAM5D,YAAY,CAACyB,OAAO,CAACtB,yBAAyB,EAAEK,IAAI,CAACkB,SAAS,CAAC,EAAE,CAAC,CAAC;IAEzE,OAAOmC,oBAAoB;EAC7B,CAAC,CAAC,OAAOnD,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,oDAAoD,EAAEA,KAAK,CAAC;IAC1E,OAAO,EAAE;EACX;AACF,CAAC;AAGD,OAAO,MAAMqD,cAAc,GAAG,MAAAA,CAAA,KAA2B;EACvD,IAAI;IACF,MAAMjD,IAAI,GAAG,MAAMT,YAAY,CAAC,CAAC;IACjC,MAAMe,GAAG,GAAG,IAAID,IAAI,CAAC,CAAC;IACtB,MAAM6C,aAAa,GAAG,IAAI7C,IAAI,CAACC,GAAG,CAAC6C,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;IAExE,MAAMC,YAAY,GAAGpD,IAAI,CAAC+B,MAAM,CAAChC,GAAG,IAAI;MACtC,MAAMoC,OAAO,GAAG,IAAI9B,IAAI,CAACN,GAAG,CAACQ,SAAS,CAAC;MACvC,OAAO4B,OAAO,IAAIe,aAAa;IACjC,CAAC,CAAC;IAEF,IAAIE,YAAY,CAACpB,MAAM,KAAKhC,IAAI,CAACgC,MAAM,EAAE;MACvC,MAAM9C,YAAY,CAACyB,OAAO,CAACvB,gBAAgB,EAAEM,IAAI,CAACkB,SAAS,CAACwC,YAAY,CAAC,CAAC;IAC5E;EACF,CAAC,CAAC,OAAOxD,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;EACrD;AACF,CAAC;AAGD,OAAO,MAAMyD,kBAAkB,GAAGA,CAACC,WAAmB,EAAEC,KAAc,KAAa;EAEjF,MAAMC,QAAQ,GAAG,GAAG;EAKpB,MAAMC,eAAe,GAAGF,KAAK,GACzBjC,IAAI,CAACoC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,GAAGJ,WAAW,IAAI,EAAE,CAAC,GACpChC,IAAI,CAACoC,GAAG,CAAC,CAAC,EAAE,CAACJ,WAAW,GAAG,EAAE,IAAI,EAAE,CAAC;EAGxC,OAAOhC,IAAI,CAACqC,GAAG,CAAC,GAAG,EAAErC,IAAI,CAACoC,GAAG,CAAC,GAAG,EAAEF,QAAQ,GAAGC,eAAe,CAAC,CAAC;AACjE,CAAC;AAGD,OAAO,MAAMG,2BAA2B,GAAG,MAAAA,CAAA,KAA6B;EACtE,IAAI;IACF,MAAM5D,IAAI,GAAG,MAAMT,YAAY,CAAC,CAAC;IACjC,MAAMsE,KAAK,GAAG,IAAIxD,IAAI,CAAC,CAAC,CAACG,WAAW,CAAC,CAAC,CAACsD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAGpD,MAAMC,aAAa,GAAG/D,IAAI,CAAC+B,MAAM,CAAChC,GAAG,IAAI;MACvC,MAAMoC,OAAO,GAAG,IAAI9B,IAAI,CAACN,GAAG,CAACQ,SAAS,CAAC,CAACC,WAAW,CAAC,CAAC,CAACsD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACnE,OAAO3B,OAAO,KAAK0B,KAAK,KAAK9D,GAAG,CAACiE,MAAM,KAAK,UAAU,IAAIjE,GAAG,CAACiE,MAAM,KAAK,UAAU,CAAC;IACtF,CAAC,CAAC;IAGF,OAAO1C,IAAI,CAACoC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAGK,aAAa,CAAC/B,MAAM,CAAC;EAC9C,CAAC,CAAC,OAAOpC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;IACjE,OAAO,CAAC;EACV;AACF,CAAC;AAGD,OAAO,MAAMqE,6BAA6B,GAAGA,CAAChC,YAAmB,EAAEiC,QAAgB,KAAW;EAG5FrE,OAAO,CAACsE,GAAG,CAAC,gBAAgB,EAAElC,YAAY,CAACD,MAAM,CAAC;EAClDnC,OAAO,CAACsE,GAAG,CAAC,YAAY,EAAED,QAAQ,CAAC;AACrC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}